/* This file was auto generated by libwmtgl. Don't edit directly. */

/*
 * Copyright (c) 2008-2011 WonderMedia Technologies, Inc. All Rights Reserved.
 *
 * This PROPRIETARY SOFTWARE is the property of WonderMedia Technologies, Inc.
 * and may contain trade secrets and/or other confidential information of
 * WonderMedia Technologies, Inc. This file shall not be disclosed to any
 * third party, in whole or in part, without prior written consent of
 * WonderMedia.
 *
 * THIS PROPRIETARY SOFTWARE AND ANY RELATED DOCUMENTATION ARE PROVIDED
 * AS IS, WITH ALL FAULTS, AND WITHOUT WARRANTY OF ANY KIND EITHER EXPRESS
 * OR IMPLIED, AND WONDERMEDIA TECHNOLOGIES, INC. DISCLAIMS ALL EXPRESS
 * OR IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * QUIET ENJOYMENT OR NON-INFRINGEMENT.
 */

#ifdef __KERNEL__
#include "com-ge.h"
#else
#include <com-ge.h>
#endif

/* import ./lib/gmp.c */

/* Generic Memory Provider */

#ifdef __KERNEL__
#include <asm/cacheflush.h>
#include <linux/wmt-mb.h>
#define  THE_MB_USER "WMT-GMP"
/* #include "gmp.h" */
#elif defined(__POST__)
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
/* #include <gmp.h> */
#else
#include <linux/fb.h>
#include <linux/errno.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
/* #include <gmp.h> */
/* #include <ge_ioctl.h> */
#endif

#ifdef __BIONIC__
#include <android/log.h>
#endif

#ifndef __LINUX__
#if !defined(__KERNEL__) && !defined(__POST__)
#define __LINUX__
#endif
#endif

#ifdef __KERNEL__
#define CHECK_GMP_USER_REF
#endif

#ifdef CHECK_GMP_USER_REF
#define MAX_GMP_USERS 16
#endif

#define IGNORE(x) (void)(x)

#define gmp_log __gmp_log
#define gmp_trace() \
	gmp_log(GMP_LOG_DEBUG, "[gmp] trace %s at line %d\n", \
	__func__, __LINE__)

#ifdef USE_UMP
typedef unsigned int ump_secure_id;
#define UMP_INVALID_SECURE_ID ((ump_secure_id)-1)
#endif

#ifdef __KERNEL__
static int gmp_device_lock(void);
static int gmp_device_unlock(void);
#endif

#ifdef CHECK_GMP_USER_REF
static void reset_gmp_users(void);
static int get_gmp_user_ref(pid_t pid);
#endif

static int gmp_log_level = GMP_LOG_ERR;

static int __gmp_log(int level, const char *fmt, ...)
{
        va_list ap;
	/* omit non-critial messages */
	if (level > gmp_log_level)
		return 0;
        va_start(ap, fmt);
#if defined(__KERNEL__)
        return vprintk(fmt, ap);
#elif defined(__BIONIC__)
        return __android_log_vprint(ANDROID_LOG_DEBUG, "gmp", fmt, ap);
#else
        return vprintf(fmt, ap);
#endif
}

#ifdef __LINUX__
static int open_fb_device(void)
{
	int fd;

	fd = open("/dev/fb0", O_RDWR);
	if (fd < 0)
		fd = open("/dev/graphics/fb0", O_RDWR, 0);
	if (fd < 0) {
		return -1;
	}
	return fd;
}
#endif

static pid_t gmp_get_owner(void)
{
	/* Kernel's current->tgid equals to user process's getpid() */
#if defined(__KERNEL__)
	return current->tgid;
#elif defined(__LINUX__)
	return getpid();
#else
	return (pid_t) 0;
#endif
}

static size_t gmp_get_order(size_t val)
{
	int order;

	order = 0;

	if (val) {
		val--;
		val >>= GMP_SHIFT;
		while (val) {
			val >>= 1;
			order++;
		}
	}

	return order;
}

/*
static void gmp_split_unused(struct gmdesc *gmdesc)
{
	struct gmdesc *p = gmdesc;
	struct gmdesc *next;

	while (p) {
		next = next_gmdesc(gmp, p);
		if (!p->used && p->order)
			p->order = 0;
		p = next;
	}
}
*/

static int gmp_split(struct gmp *gmp, struct gmdesc *gmdesc)
{
	struct gmdesc *newdesc;
	unsigned long ofs;

	IGNORE(gmp);

	if (gmdesc && gmdesc->order) {
		gmdesc->order--;
		newdesc = gmdesc + GMP_NR(gmdesc);
		ofs = GMP_SIZE(gmdesc);
		if (newdesc->pa != gmdesc->pa + ofs) {
			gmp_log(GMP_LOG_ERR,
				   "[gmp] split failure (%p != %p)\n",
				   (void *) newdesc->pa,
				   (void *) (gmdesc->pa + ofs));
			return -EFAULT;
		}
		newdesc->order = gmdesc->order;
		newdesc->used  = gmdesc->used;
		newdesc->tag   = GMP_TAG_DEFAULT;
		newdesc->tail  = gmdesc->tail;
#ifdef USE_UMP
		newdesc->secure_id = (unsigned int) -1;
#endif /* USE_UMP */
		gmdesc->tail = 0;
		return 0;
	}

	gmp_log(GMP_LOG_ERR, "[gmp] split failure\n");

	return -EINVAL;
}

static int gmp_merge(struct gmp *gmp, struct gmdesc *gmdesc)
{
	unsigned long start;
	int unaligned;
	struct gmdesc *p;

	start = gmdesc->pa - gmp->gmdesc->pa;
	unaligned = (start >> (gmdesc->order + GMP_SHIFT)) & 1;

	if (gmdesc->used || unaligned)
		return -EINVAL;

	if (next_gmdesc(gmp, gmdesc)) {
		p = next_gmdesc(gmp, gmdesc);
		if (p->used)
			return -EINVAL;

		gmp_merge(gmp, p);

		if (p->order == gmdesc->order) {
			gmdesc->order++;
			gmdesc->tail = p->tail;
			p->tail = 0;
			while (gmp_merge(gmp, gmdesc) == 0);
			return 0;
		}
	}

	return -EINVAL;
}

struct gmdesc *next_gmdesc(struct gmp *gmp, struct gmdesc *gmdesc)
{
	struct gmdesc *p;

	IGNORE(gmp);

	p = gmdesc;

	if (p->tail)
		return NULL;

	p += GMP_NR(p);

	return p;
}

struct gmdesc *prev_gmdesc(struct gmp *gmp, struct gmdesc *gmdesc)
{
	struct gmdesc *p;
	struct gmdesc *next;

	if (gmdesc == gmp->gmdesc)
		return NULL;

	next = gmp->gmdesc;
	while (next != gmdesc) {
		p = next;
		next = next_gmdesc(gmp, p);
	}
	if (next == gmdesc)
		return p;

	return NULL;
}

void gmp_reset(struct gmp *gmp)
{
	struct gmdesc *gmdesc;
	struct gmdesc *p;
	unsigned long addr;
	int gmdesc_nr;
	int len;

	if (!gmp)
		return;

	gmp_trace();

	gmp_log(GMP_LOG_CRIT, "[gmp] reset memory descriptors\n");

	gmdesc = gmp->gmdesc;
	gmdesc_nr = gmp->len >> GMP_SHIFT;
	len = sizeof(struct gmdesc) * gmdesc_nr;

	if (gmdesc_nr == 0)
		return;

	/* initialize memory descriptors */
	memset(gmdesc, 0, len);
	p = gmdesc;
	addr = gmp->pa;
	while (gmdesc_nr--) {
		p->pa = addr;
		p->tag = GMP_TAG_DEFAULT;
#ifdef USE_UMP
		p->secure_id = (unsigned int) -1;
#endif /* USE_UMP */
		p++;
		addr += (1 << GMP_SHIFT);
	}
	p--;
	p->tail = 1;

	/* defrag memory (forward) */
	while (p) {
		gmp_merge(gmp, p);
		p = prev_gmdesc(gmp, p);
	}

	/* claim 1st block for descriptors */
	gmp_alloc(gmp, len, gmp_ctag('g', 'm', 'p', ' '));

	/* memory owned by pid -1 was never released */
	gmp->gmdesc->owner = (pid_t) -1;
}

int gmp_lock(struct gmp *gmp)
{
#if defined(__KERNEL__)
	return gmp_device_lock();
#elif defined(__LINUX__)
	return ioctl(gmp->hnd, GMP_LOCK, 1);
#else
	return 0;
#endif
}

int gmp_unlock(struct gmp *gmp)
{
#if defined(__KERNEL__)
	return gmp_device_unlock();
#elif defined(__LINUX__)
	return ioctl(gmp->hnd, GMP_LOCK, 0);
#else
	return 0;
#endif
}

static size_t size_of_gmdesc_array(struct gmp *gmp)
{
	size_t gmdesc_nr;
	size_t len;

	gmdesc_nr = gmp->len >> GMP_SHIFT;
	len = sizeof(struct gmdesc) * gmdesc_nr;

	return len;
}

static void gmp_flush_gmdesc(struct gmp *gmp)
{
	unsigned long gmdesc_start;
	int gmdesc_size;

	gmdesc_start = gmp->pa;
	gmdesc_size = size_of_gmdesc_array(gmp);
	gmp_cache_flush(gmp, gmdesc_start, gmdesc_size);
}

struct gmp *create_gmp(unsigned long pa, size_t size)
{
	struct gmp *gmp;
	size_t len;
	int hnd;

	gmp_trace();

	hnd = 0;

#ifdef __LINUX__
	if ((hnd = open("/dev/gmp", O_RDWR)) < 0) {
		gmp_log(GMP_LOG_ERR,
			"[gmp] cannot open device\n");
		return NULL;
	}
	if (size == 0)
		ioctl(hnd, GMP_GET_SIZE, &size);
	if (pa == 0)
		ioctl(hnd, GMP_GET_PHYS, &pa);
#endif

	if ((pa & GMP_MASK) || pa == 0) {
		gmp_log(GMP_LOG_ERR,
			"[gmp] Cannot use unaligned memory %p\n",
			(void *) pa);
		return NULL;
	}

	if ((size & GMP_MASK) || size == 0) {
		gmp_log(GMP_LOG_ERR,
			"[gmp] Memory size (%d) is invalid\n",
			(int) size);
		return NULL;
	}

#ifdef __KERNEL__
	gmp = (struct gmp *) kcalloc(1, sizeof(struct gmp), GFP_KERNEL);
#else
	gmp = (struct gmp *) calloc(1, sizeof(struct gmp));
#endif
	gmp->pa = pa;
	gmp->len = size;
	gmp->hnd = hnd;
	gmp->cached = NULL;

	len = size_of_gmdesc_array(gmp);
	gmp->gmdesc = (struct gmdesc *) gmp_ioremap(gmp, gmp->pa, len);
	if (!gmp->gmdesc)
		gmp_log(GMP_LOG_ERR,
			"[gmp] cannot ioremap %p for %d bytes\n",
			gmp->pa, len);

	gmp_flush_gmdesc(gmp);

#ifdef __KERNEL__
	/* initial memory descriptor once */
	if (gmp->gmdesc && !gmp->gmdesc->used) {
		gmp_reset(gmp);
		gmp_print_status(gmp);
#ifdef CHECK_GMP_USER_REF
		reset_gmp_users();
#endif
	}
#endif
	/* recovery damaged descriptor */
	if (gmp->gmdesc && gmp->gmdesc->pa != gmp->pa) {
		gmp_log(GMP_LOG_ERR, "[gmp] recovery damaged descriptors\n");
		gmp_reset(gmp);
	}

	return gmp;
}

void release_gmp(struct gmp *gmp)
{
	size_t len;

	if (!gmp)
		return;

	gmp_trace();

#ifdef  CHECK_GMP_USER_REF
	if (get_gmp_user_ref(gmp_get_owner()) == 0)
		gmp_invalidate(gmp, gmp_get_owner());
#endif

	len = size_of_gmdesc_array(gmp);
	gmp_iounmap(gmp, (void *) gmp->gmdesc, len);

#ifdef __LINUX__
	if (gmp->hnd)
		close(gmp->hnd);
#endif
#ifdef __KERNEL__
	kfree(gmp);
#else
	free(gmp);
#endif
}

void gmp_invalidate(struct gmp *gmp, pid_t pid)
{
	struct gmdesc *p;

	gmp_trace();

	if (!gmp)
		return;

	/* Release all memory owned by pid */
	p = gmp->gmdesc;
	while (p) {
		if (p->owner == pid) {
			p->used = 0;
			p->tag = GMP_TAG_DEFAULT;
			p->owner = 0;
#ifdef USE_UMP
			p->secure_id = (unsigned int) -1;
#endif /* USE_UMP */
		}
		p = next_gmdesc(gmp, p);
	}

	/* Defrag memory */
	p = gmp->gmdesc;
	while (p) {
		gmp_merge(gmp, p);
		p = next_gmdesc(gmp, p);
	}
}

void gmp_cache_flush(struct gmp *gmp, unsigned long physaddr, size_t size)
{
#if defined(__LINUX__)
	struct gmp_region region;
	region.pa = physaddr;
	region.len = size;
	ioctl((int) gmp->hnd, GMP_CACHE_FLUSH, &region);
#elif defined(__KERNEL__)
	void *flush_start = ioremap(physaddr, size);
	void *flush_end = flush_start + size;
	if (flush_start) {
		dmac_flush_range(flush_start, flush_end);
		outer_flush_range(__pa(flush_start), __pa(flush_end));
		iounmap(flush_start);
	}
#endif
}

void *gmp_ioremap(struct gmp *gmp, unsigned long physaddr, size_t size)
{
#if defined(__LINUX__)
	struct fb_fix_screeninfo fsinfo;
	int fd;
	off_t off;
	void *va;
	unsigned long smem_start;
	int err;

	gmp_trace();

	/* try gmp */

	fd = (int) gmp->hnd;
	err = 0;

	if (ioctl(fd, GMP_GET_PHYS, &smem_start) < 0) {
		gmp_log(GMP_LOG_ERR, "[gmp] ioctl GMP_GET_PHYS error\n");
		err++;
	}

	if (physaddr < smem_start) {
		gmp_log(GMP_LOG_INFO, "[gmp] cannot map %p below %p\n",
			physaddr, smem_start);
		err++;
	}

	if (!err) {
		off = ((physaddr - smem_start) + 0xfff) & ~0xfff;
		va = mmap((void *) 0, size,
		PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);
		if (va != MAP_FAILED)
			return va;
	}

	/* try linuxfb */

	fd = open_fb_device();

	ioctl(fd, FBIOGET_FSCREENINFO, &fsinfo);

	if (physaddr < fsinfo.smem_start) {
		gmp_log(GMP_LOG_INFO, "[gmp] cannot map %p below %p\n",
			physaddr, fsinfo.smem_start);
		close(fd);
		return NULL;
	}

	off = ((physaddr - fsinfo.smem_start) + 0xfff) & ~0xfff;
	va = mmap((void *) 0, size,
		PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);

	close(fd);

	if (va == MAP_FAILED) {
		gmp_log(GMP_LOG_ERR, "[gmp] cannot map %p for %d bytes\n",
			physaddr, size);
		return NULL;
	}

	return va;
#elif defined(__KERNEL__)
	return ioremap(physaddr, size);
#elif defined(__POST__)
	return (void *) physaddr;
#else
	return NULL;
#endif
}

void gmp_iounmap(struct gmp *gmp, void *va, size_t size)
{
	IGNORE(gmp);

	gmp_trace();

#if defined(__LINUX__)
	if (va)
		munmap(va, size);
#elif defined(__KERNEL__)
	if (va)
		iounmap(va);
#endif
}

void gmp_get_status(struct gmp *gmp, int *used, int *avail)
{
	struct gmdesc *p;
	unsigned int i_used;
	unsigned int i_avail;

	gmp_trace();

	i_used = 0;
	i_avail = 0;
	p = gmp->gmdesc;

	while (p) {
		if (p->used)
			i_used += GMP_SIZE(p);
		else
			i_avail += GMP_SIZE(p);
		p = next_gmdesc(gmp, p);
	}

	*used = i_used;
	*avail = i_avail;
}

unsigned int gmp_itag(unsigned int value)
{
	unsigned int value2;
	char *s1 = (char *) &value;
	char *s2 = (char *) &value2;
	/* return if value is ascii code */
	if (s1[0] >= 0x20)
		return value;
	/* convert integer to ascii code */
	s2[0] = s1[3];
	s2[1] = s1[2];
	s2[2] = s1[1];
	s2[3] = s1[0];
	if (s2[0] < 0x30)
		s2[0] += 0x30;
	if (s2[1] < 0x30)
		s2[1] += 0x30;
	if (s2[2] < 0x30)
		s2[2] += 0x30;
	if (s2[3] < 0x30)
		s2[3] += 0x30;
	return value2;
}

unsigned int gmp_ctag(char a, char b, char c, char d)
{
	unsigned int value;
	char *s = (char *) &value;
	s[0] = a;
	s[1] = b;
	s[2] = c;
	s[3] = d;
	return value;
}

void gmp_print_status(struct gmp *gmp)
{
	struct gmdesc *p;
	const char *tag;
	unsigned int i_used;
	unsigned int i_avail;

	if (gmp_log_level < GMP_LOG_INFO)
		return;

	gmp_trace();

	i_used = 0;
	i_avail = 0;
	p = gmp->gmdesc;

	while (p) {
		tag = (const char *) &p->tag;
#ifdef USE_UMP
		gmp_log(GMP_LOG_DEBUG,
			"[gmp] pa: 0x%08lx, order: %d, used: %d, "
			"tag: %c%c%c%c, owner: %d, id: %d\n",
			p->pa, p->order, p->used,
			tag[0], tag[1], tag[2], tag[3],
			p->owner, p->secure_id);
#else
		gmp_log(GMP_LOG_DEBUG,
			"[gmp] pa: 0x%08lx, order: %d, used: %d, "
			"tag: %c%c%c%c, owner: %d\n",
			p->pa, p->order, p->used,
			tag[0], tag[1], tag[2], tag[3],
			p->owner);
#endif
		if (p->used) {
			i_used += 1 << (p->order + GMP_SHIFT - 10);
		} else {
			i_avail += 1 << (p->order + GMP_SHIFT - 10);
		}
		p = next_gmdesc(gmp, p);
	}

	gmp_log(GMP_LOG_INFO, "[gmp] used: %d KB, free: %d KB\n",
		   i_used, i_avail);
}

#ifdef USE_UMP
#ifdef __KERNEL__
extern unsigned int (*mali_get_ump_secure_id)(unsigned int addr, unsigned int size);
extern void         (*mali_put_ump_secure_id)(unsigned int ump_id);
#else
static unsigned int (*mali_get_ump_secure_id)(unsigned int addr, unsigned int size);
static void         (*mali_put_ump_secure_id)(unsigned int ump_id);
#endif

unsigned int gmp_get_secure_id(struct gmp *gmp, unsigned long pa)
{
	struct gmdesc *p;

	gmp_trace();

	p = gmp->cached;

	if (p && p->pa == pa)
		return p->secure_id;

	p = gmp->gmdesc;

	while (p) {
		if (p->pa == pa)
			break;
		p = next_gmdesc(gmp, p);
	}

	if (p)
		return p->secure_id;

	return (unsigned int) -1;
}

unsigned long gmp_get_addr_from_secure_id(struct gmp *gmp, unsigned int secure_id)
{
	struct gmdesc *p;

	gmp_trace();

	p = gmp->cached;

	if (p && p->secure_id == secure_id)
		return p->pa;

	p = gmp->gmdesc;

	while (p) {
		if (p->secure_id == secure_id)
			break;
		p = next_gmdesc(gmp, p);
	}

	if (p)
		return p->pa;

	return 0;
}

unsigned int gmp_get_size_from_secure_id(struct gmp *gmp, unsigned int secure_id)
{
	struct gmdesc *p;

	gmp_trace();

	p = gmp->cached;

	if (p && p->secure_id == secure_id)
		return GMP_SIZE(p);

	p = gmp->gmdesc;
	while (p) {
		if (p->secure_id == secure_id)
			break;
		p = next_gmdesc(gmp, p);
	}
	if (p)
		return GMP_SIZE(p);

	return 0;
}
#endif

unsigned long gmp_alloc(struct gmp *gmp, size_t size, unsigned int tag)
{
	struct gmdesc *p;
	int order;
	pid_t pid;

	gmp_trace();

	gmp_log(GMP_LOG_INFO, "[gmp] alloc %d bytes\n", (int) size);

	pid = gmp_get_owner();
	order = gmp_get_order(size);

	p = gmp->gmdesc;

	while (p) {
		if (!p->used && p->order >= order) {
			if (p->order == order)
				break;
			while (p->order > order) {
				gmp_split(gmp, p);
			}
			break;
		}
		p = next_gmdesc(gmp, p);
	}

	gmp->cached = p;

	if (p && !p->used) {
		p->used = 1;
#ifdef USE_UMP
		p->tag = tag == GMP_TAG_UMP ? tag : gmp_itag(tag);

		if (tag == GMP_TAG_UMP && mali_get_ump_secure_id)
			p->secure_id = (*mali_get_ump_secure_id)(
					p->pa, GMP_SIZE(p));
		else
			p->secure_id = (unsigned int) -1;
#else  /* USE_UMP */
		p->tag = gmp_itag(tag);
#endif /* USE_UMP */
		p->owner = pid;
		gmp_print_status(gmp);

		return p->pa; /* success */
	}

	gmp_log(GMP_LOG_ERR, "[gmp] cannot allocate %d bytes\n", size);
	gmp_print_status(gmp);

	return 0;
}

void gmp_free(struct gmp *gmp, unsigned long pa)
{
	struct gmdesc *p;
#ifndef USE_UMP
	pid_t pid;
#endif

	gmp_trace();

#ifndef USE_UMP
	pid = gmp_get_owner();
#endif
	gmp_log(GMP_LOG_INFO, "[gmp] free %p\n", (void *) pa);

	p = gmp->cached;

	if (!p || p->pa != pa) {
		p = gmp->gmdesc;

		while (p) {
#ifdef USE_UMP
			if (p->pa == pa)
				break;
#else
			if (p->pa == pa && p->owner == pid)
				break;
#endif
			p = next_gmdesc(gmp, p);
		}
	}

	if (p) {
		p->used  = 0;
		p->tag   = GMP_TAG_DEFAULT;
		p->owner = 0;
#ifdef USE_UMP
		if (p->secure_id != UMP_INVALID_SECURE_ID
			&& mali_put_ump_secure_id) {
			(*mali_put_ump_secure_id)(p->secure_id);
		}
		p->secure_id = (unsigned int) -1;
#endif /* USE_UMP */
	}

	/* memory defragment */
	p = gmp->gmdesc;
	while (p) {
		gmp_merge(gmp, p);
		p = next_gmdesc(gmp, p);
	}

	gmp_print_status(gmp);
}

void gmp_set_log_level(int level)
{
	gmp_log_level = level;
}

/* GMP Linux Kernel Driver */
/*
 * GMP device has to register before using GMP API.
 *
 * int register_gmp_device(unsigned long physaddr, unsigned long size)
 * int unregister_gmp_device(void)
 */

#ifdef __KERNEL__
#include <asm/uaccess.h>
#include <linux/cdev.h>
#include <linux/proc_fs.h>
#include <linux/mm.h>
#include <linux/fs.h>
#ifndef LINUX_VERSION_CODE
#include <linux/version.h>
#endif /* LINUX_VERSION_CODE */
#define GMP_DEV_NAME		"gmp"
static int gmp_device_open(struct inode *inode, struct file *filp);
static int gmp_device_release(struct inode *inode, struct file *filp);
static int gmp_device_mmap(struct file *file, struct vm_area_struct * vma);
#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
static int gmp_device_ioctl(struct inode *inode, struct file *filp,
			    unsigned int command, unsigned long arg);
static DECLARE_MUTEX(gmp_sem);
#else
static long gmp_device_ioctl(struct file *filp, unsigned int cmd,
			     unsigned long arg);
static DEFINE_SEMAPHORE(gmp_sem);
#endif
static DEFINE_MUTEX(gmp_mutex);
static struct task_struct *gmp_sem_owner;
static struct gmp *g_gmp;
static struct proc_dir_entry *gmp_procfs_dir;
static struct proc_dir_entry *gmp_procfs_status_file;
static int init_procfs_gmp(void);
static void exit_procfs_gmp(void);
static int gmp_busy_flag;
static struct class *gmp_device_class;
static dev_t gmp_id;
static unsigned long gmp_smem_start;
static unsigned long gmp_smem_len;

static const struct file_operations gmp_device_fops = {
	.open		= gmp_device_open,
	.release	= gmp_device_release,
#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,32)
	.ioctl		= gmp_device_ioctl,
#else
	.unlocked_ioctl = gmp_device_ioctl,
#endif
	.mmap		= gmp_device_mmap,
	.owner		= THIS_MODULE,
};

static struct cdev gmp_device = {
	.owner = THIS_MODULE,
};

int register_gmp_device(unsigned long physaddr, unsigned long size)
{
	int err;
	dev_t dev;

	if (physaddr == 0 || size == 0)
		return -ENOMEM;

	err = alloc_chrdev_region(&dev, 0, 1, GMP_DEV_NAME);
	if (err) {
		printk(KERN_ERR "%s: register_chrdev_region = %d\n",
			__func__, err);
		return -EFAULT;
	}

	cdev_init(&gmp_device, &gmp_device_fops);

	err = cdev_add(&gmp_device, dev, 1);

	if (err) {
		printk(KERN_ERR "%s: cdev_add = %d\n", __func__, err);
		unregister_chrdev_region(dev, 1);
		return -EFAULT;
	}

	printk("gmp was registered as device (%d,%d)\n",
		MAJOR(dev), MINOR(dev));

	/* let udev to handle /dev/gmp_device */
	gmp_device_class = class_create(THIS_MODULE, GMP_DEV_NAME);
	device_create(gmp_device_class, NULL, dev, NULL, "%s",
			GMP_DEV_NAME);

	gmp_id = dev;

	/* should not request_mem_region here */
	request_mem_region(physaddr, size, GMP_DEV_NAME);

	g_gmp = NULL;
	gmp_busy_flag = 0;

	gmp_set_log_level(GMP_LOG_ERR);
	g_gmp = create_gmp(physaddr, size);

	gmp_smem_start = physaddr;
	gmp_smem_len = size;

	init_procfs_gmp();

	return 0;
}

int unregister_gmp_device(void)
{
	dev_t dev;

	dev = gmp_id;

	exit_procfs_gmp();

	if (g_gmp) {
		release_gmp(g_gmp);
		g_gmp = NULL;
	}

	/* let udev to handle /dev/gmp_device */
	device_destroy(gmp_device_class, dev);
	class_destroy(gmp_device_class);

	unregister_chrdev_region(dev, 1);
	cdev_del(&gmp_device);

	return 0;
}

static int gmp_device_lock(void)
{
        int ret;
        ret = down_interruptible(&gmp_sem);
	if (ret == 0) {
		mutex_lock(&gmp_mutex);
		gmp_sem_owner = current;
		gmp_busy_flag = 1;
		mutex_unlock(&gmp_mutex);
	}
	return ret;
}

static int gmp_device_unlock(void)
{
	if (gmp_sem_owner == current) {
		up(&gmp_sem);
		mutex_lock(&gmp_mutex);
		gmp_busy_flag = 0;
		mutex_unlock(&gmp_mutex);
	} else
		return -1;
	return 0;
}

#ifdef CHECK_GMP_USER_REF

struct gmp_user {
	pid_t pid;
	int ref;
};

static struct gmp_user gmp_users[MAX_GMP_USERS];

static void reset_gmp_users(void)
{
	memset(gmp_users, 0, sizeof(struct gmp_user));
}

static int get_gmp_user_ref(pid_t pid)
{
	int i = 0;
	int ref = 0;

	while (i < MAX_GMP_USERS) {
		if (gmp_users[i].pid == pid) {
			ref = gmp_users[i].ref;
			break;
		}
		i++;
	}

	return ref;
}

static void add_gmp_user(pid_t pid)
{
	int i = 0;

	while (i < MAX_GMP_USERS) {
		if (gmp_users[i].pid == pid) {
			gmp_users[i].ref++;
			return;
		}
		i++;
	}

	i = 0;

	while (i < MAX_GMP_USERS) {
		if (gmp_users[i].pid == 0) {
			gmp_users[i].pid = pid;
			gmp_users[i].ref = 1;
			return;
		}
		i++;
	}
}

static void remove_gmp_user(pid_t pid)
{
	int i = 0;

	while (i < MAX_GMP_USERS) {
		if (gmp_users[i].pid == pid) {
			gmp_users[i].ref--;
			if (gmp_users[i].ref == 0)
				gmp_users[i].pid = 0;
			return;
		}
		i++;
	}
}
#endif /* CHECK_GMP_USER_REF */

static int gmp_device_open(struct inode *inode, struct file *filp)
{
	filp->private_data = (void *) current->tgid;

#ifdef CHECK_GMP_USER_REF
	mutex_lock(&gmp_mutex);
	add_gmp_user(current->tgid);
	mutex_unlock(&gmp_mutex);
#endif /* CHECK_GMP_USER_REF */

	gmp_log(GMP_LOG_DEBUG, "%s: %s, pid %d, tgid %d\n",
		__func__, current->comm, current->pid, current->tgid);

	return 0;
}

static int gmp_device_release(struct inode *inode, struct file *filp)
{
	pid_t pid;

	gmp_device_unlock();

	pid = (pid_t) filp->private_data;

	mutex_lock(&gmp_mutex);
#ifdef CHECK_GMP_USER_REF
	remove_gmp_user(pid);
	if (get_gmp_user_ref(pid) == 0)
		gmp_invalidate(g_gmp, pid);
#else
	gmp_invalidate(g_gmp, pid);
#endif /* CHECK_GMP_USER_REF */
	mutex_unlock(&gmp_mutex);

	gmp_log(GMP_LOG_DEBUG, "%s: %s, pid %d, tgid %d\n",
		__func__, current->comm, current->pid, current->tgid);

	return 0;
}

#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,36)
static int gmp_device_ioctl(struct inode *inode, struct file *filp,
	unsigned int cmd, unsigned long arg)
#else
static long gmp_device_ioctl(struct file *filp, unsigned int cmd,
			     unsigned long arg)
#endif
{
	void __user *argp;
	int ret;
	struct gmp_region region;
#ifdef USE_UMP
	unsigned int addr;
	unsigned int len;
	unsigned int secure_id;
#endif

	argp = (void __user *)arg;

	switch (cmd) {
	case GMP_GET_PHYS:
		mutex_lock(&gmp_mutex);
		copy_to_user(argp, &gmp_smem_start, sizeof(unsigned long));
		mutex_unlock(&gmp_mutex);
		ret = 0;
                break;
	case GMP_GET_SIZE:
		mutex_lock(&gmp_mutex);
		copy_to_user(argp, &gmp_smem_len, sizeof(unsigned long));
		mutex_unlock(&gmp_mutex);
		ret = 0;
                break;
	case GMP_LOCK:
		if (arg)
			ret = gmp_device_lock();
		else
			ret = gmp_device_unlock();
                break;
	case GMP_CACHE_FLUSH:
		if (copy_from_user(&region, argp, sizeof(struct gmp_region)))
			return -EFAULT;
		gmp_cache_flush(g_gmp, region.pa, region.len);
		ret = 0;
		break;
	case GMP_CACHE_FLUSH_ALL:
		gmp_cache_flush(g_gmp, gmp_smem_start, gmp_smem_len);
		ret = 0;
		break;
#ifdef USE_UMP
	case GMP_ALLOC_UMP:
		if (mali_get_ump_secure_id == NULL)
			return -EFAULT;
		len = arg;
		addr = gmp_alloc(g_gmp, len, GMP_TAG_UMP);
		ret = gmp_get_secure_id(g_gmp, addr);
		break;
	case GMP_FREE_UMP:
		secure_id = arg;
		addr = gmp_get_addr_from_secure_id(g_gmp, secure_id);
		if (addr)
			gmp_free(g_gmp, addr);
		ret = addr ? 0 : -EFAULT;
		break;
	case GMP_GET_UMP_PHYS:
		secure_id = arg;
		addr = gmp_get_addr_from_secure_id(g_gmp, secure_id);
		ret = addr;
		break;
	case GMP_GET_UMP_SIZE:
		secure_id = arg;
		len = gmp_get_size_from_secure_id(g_gmp, secure_id);
		ret = len;
		break;
	case GMP_MAP_UMP:
		if (copy_from_user(&region, argp, sizeof(struct gmp_region)))
			return -EFAULT;
		if (mali_get_ump_secure_id)
			ret = (*mali_get_ump_secure_id)(region.pa, region.len);
		else
			ret = UMP_INVALID_SECURE_ID;
		break;
	case GMP_UNMAP_UMP:
		secure_id = arg;
		if (secure_id != UMP_INVALID_SECURE_ID
		    && mali_put_ump_secure_id) {
			(*mali_put_ump_secure_id)(secure_id);
			ret = 0;
		}
		else
			ret = -EFAULT;
		break;
	case GMP_GET_MB:
		if (copy_from_user(&region, argp, sizeof(struct gmp_region)))
			return -EFAULT;
		mb_get(region.pa);
		ret = 0;
		break;
	case GMP_PUT_MB:
		if (copy_from_user(&region, argp, sizeof(struct gmp_region)))
			return -EFAULT;
		mb_put(region.pa);
		ret = 0;
		break;
#endif /* USE_UMP */
	default:
		ret = -1;
	}


	return ret;
}

static int gmp_device_mmap(struct file *file, struct vm_area_struct * vma)
{
	unsigned long off;
	unsigned long start;
	u32 len;

	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
		gmp_log(GMP_LOG_ERR, "[gmp] gmp_device_mmap fail #1\n");
		return -EINVAL;
	}
	off = vma->vm_pgoff << PAGE_SHIFT;

	start = gmp_smem_start;
	len = PAGE_ALIGN((start & ~PAGE_MASK) + gmp_smem_len);

	if (off >= len) {
		gmp_log(GMP_LOG_ERR, "[gmp] gmp_device_mmap fail #2\n");
		return -EINVAL;
	}
	start &= PAGE_MASK;
	if ((vma->vm_end - vma->vm_start + off) > len) {
		gmp_log(GMP_LOG_ERR, "[gmp] gmp_device_mmap fail #3\n");
		return -EINVAL;
	}
	off += start;
	vma->vm_pgoff = off >> PAGE_SHIFT;

	vma->vm_flags |= VM_IO | VM_RESERVED;

	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
		vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
		gmp_log(GMP_LOG_ERR, "[gmp] gmp_device_mmap fail #3\n");
		return -EAGAIN;
	}

	return 0;
}

static int gmp_proc_read_status(char *page, char **start,
				   off_t off, int count,
				   int *eof, void *data)
{
	struct gmdesc *p;
	const char *tag;
	unsigned int i_used;
	unsigned int i_avail;
	int len;
	char *s;
	int ret;
	struct gmp *gmp;

	gmp = (struct gmp *) data;

	/* recovery damaged descriptor */
	if (gmp->gmdesc && gmp->gmdesc->pa != gmp->pa) {
		gmp_log(GMP_LOG_ERR, "[gmp] recovery damaged descriptors\n");
		gmp_reset(gmp);
	}

	p = gmp->gmdesc;
	s = page;
	ret = 0;
	i_used = 0;
	i_avail = 0;

	while (p) {
		tag = (const char *) &p->tag;
		len = sprintf(
			s,
			"[gmp] pa: 0x%08lx, order: %d, used: %d, "
			"tag: %c%c%c%c, owner: %d, id: %d, size: %d KB\n",
			p->pa, p->order, p->used,
			tag[0], tag[1], tag[2], tag[3],
			p->owner, p->secure_id, 1 << (p->order + GMP_SHIFT - 10));
		s += len;
		ret += len;
		if (p->used)
			i_used += 1 << (p->order + GMP_SHIFT - 10);
		else
			i_avail += 1 << (p->order + GMP_SHIFT - 10);
		p = next_gmdesc(gmp, p);
	}

	len = sprintf(s, "[gmp] used: %d KB, free: %d KB, busy: %d\n",
		i_used, i_avail, gmp_busy_flag);
	ret += len;

	return ret;
}

static int __init init_procfs_gmp(void)
{
	int ret = 0;

	gmp_procfs_dir = proc_mkdir("gmp", NULL);

	if (gmp_procfs_dir == NULL) {
		ret = -ENOMEM;
		goto out;
	}

	gmp_procfs_status_file = create_proc_read_entry("meminfo", 0444,
		gmp_procfs_dir, gmp_proc_read_status, NULL);

	if (gmp_procfs_status_file == NULL) {
		ret = -ENOMEM;
		goto no_status;
	}

	gmp_procfs_status_file->data = (void *) g_gmp;

	return 0;

no_status:			      
	remove_proc_entry("gmp", NULL);
out:
	return ret;

}

static void exit_procfs_gmp(void)
{
	remove_proc_entry("meminfo", gmp_procfs_dir);
	remove_proc_entry("gmp", NULL);
}

#endif /* __KERNEL__ */


/* import ./lib/ge_log.c */

#ifndef __KERNEL__
#ifndef __POST__
#include <features.h>
#endif
#include <stdio.h>
#include <stdarg.h>

#ifdef __BIONIC__
#include <android/log.h>
#endif

/* #include <ge_log.h> */

static int ge_log_level = GE_LOG_ERR;

int __ge_log(int level, const char *fmt, ...)
{
        va_list ap;
	/* omit non-critial messages */
	if (level > ge_log_level)
		return 0;
        va_start(ap, fmt);
#if defined(__KERNEL__)
        return vprintk(fmt, ap);
#elif defined(__BIONIC__)
        return __android_log_vprint(ANDROID_LOG_DEBUG, "libwmtgl", fmt, ap);
#else
        return vprintf(fmt, ap);
#endif
}

void ge_set_log_level(int level)
{
	ge_log_level = level;
}
#else  /* __KERNEL__ */
int __ge_log(int level, const char *fmt, ...)
{
	return 0;
}

void ge_set_log_level(int level)
{
	return;
}
#endif /* __KERNEL__ */

/* import ./lib/ge_plugin.c */

#define IGNORE(x) (void)(x)

#if !defined(__KERNEL__) && !defined(__POST__) && !defined(BUILD_STATIC)
#include <stdio.h>
#include <stdlib.h>
/* #include <ge_plugin.h> */
/*
#include <com-video.h>
#include <com-vpp.h>
*/

#define LOAD_FUNC(plugin, func) 			\
{							\
  plugin->func = (__typeof__(plugin->func))		\
    dlsym(handle, (const char *) #func);		\
  error = dlerror();					\
  if (error != NULL) {					\
    fprintf(stderr, "%s\n", error);			\
    plugin->func = NULL;				\
    plugin->errors++;					\
  }							\
}

#define UNLOAD_FUNC(plugin, func) 			\
{							\
  plugin->func = NULL;					\
}

struct ge_plugin *create_ge_plugin(void)
{
	struct ge_plugin *plugin;
	void *handle;
	const char *error;

	plugin = (struct ge_plugin *) calloc(1, sizeof(struct ge_plugin));

	handle = dlopen("libwmtapi.so", RTLD_LAZY);

	if (!handle) {
		fprintf(stderr, "%s\n", dlerror());
		return NULL;
	}
	dlerror();

	LOAD_FUNC(plugin, wmt_vpp_init);
	LOAD_FUNC(plugin, wmt_vpp_exit);
	LOAD_FUNC(plugin, wmt_vpp_scl_drop_line_enable);
	LOAD_FUNC(plugin, wmt_vpp_scl_scale);
	LOAD_FUNC(plugin, wmt_vpp_get_framerate);
	LOAD_FUNC(plugin, wmt_vpp_set_framerate);

	/* video overlay function */
	LOAD_FUNC(plugin, wmt_vpp_vpu_clr_fbdisp);
	LOAD_FUNC(plugin, wmt_vpp_vpu_get_fbinfo);
	LOAD_FUNC(plugin, wmt_vpp_vpu_set_fbinfo);
	LOAD_FUNC(plugin, wmt_vpp_vpu_get_view);
	LOAD_FUNC(plugin, wmt_vpp_vpu_set_view);
	LOAD_FUNC(plugin, wmt_vpp_govw_set_ge_visible);
	LOAD_FUNC(plugin, wmt_vpp_govw_set_vpu_visible);
	LOAD_FUNC(plugin, wmt_vpp_get_fbinfo);
	LOAD_FUNC(plugin, wmt_vpp_set_fbinfo);
	LOAD_FUNC(plugin, wmt_vpp_get_resolution);
	LOAD_FUNC(plugin, wmt_vpp_set_fbdisp);
	LOAD_FUNC(plugin, wmt_vpp_wait_frame);

	/* mb */
	LOAD_FUNC(plugin, wmt_mb_init);
	LOAD_FUNC(plugin, wmt_mb_exit);
	LOAD_FUNC(plugin, wmt_mb_get);
	LOAD_FUNC(plugin, wmt_mb_put);
	LOAD_FUNC(plugin, wmt_mb_user2phys);
	LOAD_FUNC(plugin, wmt_mb_alloc);
	LOAD_FUNC(plugin, wmt_mb_free);

	plugin->handle = handle;

	if (plugin->wmt_vpp_init() < 0)
		plugin->errors++;

	/*
	plugin->ofps = plugin->wmt_vpp_get_framerate(VPP_MOD_SCL);
	plugin->wmt_vpp_set_framerate(VPP_MOD_SCL, 0x7fffffff);
	*/

	if (plugin->errors) {
		free(plugin);
		return NULL;
	}

	return plugin;
}

void release_ge_plugin(struct ge_plugin *plugin)
{
	if (!plugin)
		return;

	/* plugin->wmt_vpp_set_framerate(VPP_MOD_SCL, plugin->ofps); */

	if (plugin->wmt_vpp_exit)
		plugin->wmt_vpp_exit();

	if (plugin->handle)
		dlclose(plugin->handle);

	UNLOAD_FUNC(plugin, wmt_vpp_init);
	UNLOAD_FUNC(plugin, wmt_vpp_exit);
	UNLOAD_FUNC(plugin, wmt_vpp_scl_drop_line_enable);
	UNLOAD_FUNC(plugin, wmt_vpp_scl_scale);
	UNLOAD_FUNC(plugin, wmt_vpp_get_framerate);
	UNLOAD_FUNC(plugin, wmt_vpp_set_framerate);

	/* video overlay function */
	UNLOAD_FUNC(plugin, wmt_vpp_vpu_clr_fbdisp);
	UNLOAD_FUNC(plugin, wmt_vpp_vpu_get_fbinfo);
	UNLOAD_FUNC(plugin, wmt_vpp_vpu_set_fbinfo);
	UNLOAD_FUNC(plugin, wmt_vpp_vpu_get_view);
	UNLOAD_FUNC(plugin, wmt_vpp_vpu_set_view);
	UNLOAD_FUNC(plugin, wmt_vpp_govw_set_ge_visible);
	UNLOAD_FUNC(plugin, wmt_vpp_govw_set_vpu_visible);
	UNLOAD_FUNC(plugin, wmt_vpp_get_fbinfo);
	UNLOAD_FUNC(plugin, wmt_vpp_set_fbinfo);
	UNLOAD_FUNC(plugin, wmt_vpp_get_resolution);
	UNLOAD_FUNC(plugin, wmt_vpp_set_fbdisp);
	UNLOAD_FUNC(plugin, wmt_vpp_wait_frame);

	/* mb */
	UNLOAD_FUNC(plugin, wmt_mb_init);
	UNLOAD_FUNC(plugin, wmt_mb_exit);
	UNLOAD_FUNC(plugin, wmt_mb_get);
	UNLOAD_FUNC(plugin, wmt_mb_put);
	UNLOAD_FUNC(plugin, wmt_mb_user2phys);
	UNLOAD_FUNC(plugin, wmt_mb_alloc);
	UNLOAD_FUNC(plugin, wmt_mb_free);

	free(plugin);
}
#else  /* !defined(__KERNEL__) && !defined(__POST__) && !defined(BUILD_STATIC) */
struct ge_plugin *create_ge_plugin(void)
{
	return (void *)0;
}

void release_ge_plugin(struct ge_plugin *plugin)
{
	IGNORE(plugin);
}
#endif /* !defined(__KERNEL__) && !defined(__POST__) && !defined(BUILD_STATIC) */

/* import ./lib/ge_regs.c */

/* #include "ge_regs.h" */
/* #include "ge_ioctl.h" */

/* GE core functions */
#ifndef INLINE
#define INLINE
#endif

#define IGNORE(x) (void)(x)

#if defined(__KERNEL__)
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
DECLARE_MUTEX(ge_sem);
#else
static DEFINE_SEMAPHORE(ge_sem);
#endif
struct task_struct *ge_sem_owner;

INLINE int ge_sys_init(ge_info_t **geinfo, void *priv)
{
	IGNORE(priv);

	ge_sem_owner = NULL;

	*geinfo = kmalloc(sizeof(ge_info_t), GFP_KERNEL);

	if (*geinfo) {
		(*geinfo)->mmio = (void *)(GE_MMIO_START + GE_MMIO_OFFSET);
		(*geinfo)->fd = 0;
		(*geinfo)->id = SCC_CHIP_ID;
		(*geinfo)->config = 0;
		(*geinfo)->data = 0;
		(*geinfo)->gmp = NULL;
		(*geinfo)->priv = NULL;
	} else
		return -1;

	return 0;
}

INLINE int ge_sys_exit(ge_info_t *geinfo, void *priv)
{
	IGNORE(priv);

	kfree(geinfo);

	return 0;
}

INLINE int ge_get_chip_id(ge_info_t *geinfo, unsigned int *chip_id)
{
	*chip_id = geinfo->id;

	return *chip_id ? 0 : -1;
}

INLINE void ge_wait_sync_timeout(ge_info_t *geinfo, int timeout)
{
	volatile ge_regs_t *regs;
	volatile int val;
	unsigned int msk = BIT8 | BIT9 | BIT19 | BIT20;

	if (!geinfo)
		return;

	regs = (ge_regs_t *)geinfo->mmio;

	if (!regs->ge_eng_en)
		return;

	if ((regs->ge_int_stat & msk) != 0)
		return;

	if ((regs->ge_int_en & BIT8)) {
		/* wait_event_interruptible(ge_wq, regs->ge_int_stat & msk); */
		if (wait_event_interruptible_timeout(ge_wq,
			regs->ge_int_stat & msk,
			msecs_to_jiffies(timeout)) == 0) {
			val = regs->ge_int_stat;
			regs->ge_int_stat = val | BIT20;
		}
	} else {
		val = 0xffff;
		while ((regs->ge_int_flag & msk) == 0 && val--);
		regs->ge_int_stat |= regs->ge_int_flag;
		regs->ge_int_flag = ~0;
		if (val < 0) {
			val = regs->ge_int_stat;
			regs->ge_int_stat = val | BIT20;
		}
	}

	/*
	if (regs->ge_int_stat & BIT20)
		printk(KERN_ERR "%s: timeout error. stat = %08x, irq_stat = %08x\n",
			__func__, regs->ge_status, regs->ge_int_stat);
	*/
}

INLINE void ge_wait_sync(ge_info_t *geinfo)
{
	ge_wait_sync_timeout(geinfo, -1);
}

#ifdef USE_GE_PWR_CTRL
extern void ge_clock_enable(int enable);
#endif /* USE_GE_PWR_CTRL */

INLINE int ge_lock(ge_info_t *geinfo)
{
	int ret;

	if (ge_sem_owner == current)
		return -EBUSY;

	ret = down_interruptible(&ge_sem);

	if (ret == 0)
		ge_sem_owner = current;

#ifdef USE_GE_PWR_CTRL
	ge_clock_enable(1);
#endif /* USE_GE_PWR_CTRL */

	return ret;
}

INLINE int ge_unlock(ge_info_t *geinfo)
{
	if (ge_sem_owner == current) {
		ge_sem_owner = NULL;
		up(&ge_sem);
	} else {
		return -EACCES;
	}

#ifdef USE_GE_PWR_CTRL
	ge_clock_enable(0);
#endif /* USE_GE_PWR_CTRL */

	return 0;
}

INLINE int ge_trylock(ge_info_t *geinfo)
{
	int ret;

	ret = down_trylock(&ge_sem);

	if (ret == 0)
		ge_sem_owner = current;

	return ret;
}
#elif defined(__LINUX__)
INLINE int ge_sys_init(ge_info_t **geinfo, void *priv)
{
	struct fb_fix_screeninfo fb_fix;
	unsigned int off;
	unsigned long p;
	int fd;
	unsigned int id;
	size_t len;

	IGNORE(priv);

	fd = open("/dev/fb0", O_RDWR);
	if (fd < 0)
		fd = open("/dev/graphics/fb0", O_RDWR, 0);
	if (fd < 0) {
		perror("ge_sys_init");
		return -EINVAL;
	}
	*geinfo = (ge_info_t *) calloc(1, sizeof(ge_info_t));
	if (*geinfo == NULL) {
		perror("ge_sys_init");
		return -EINVAL;
	}
	(*geinfo)->fd = fd;

	ioctl(fd, FBIOGET_FSCREENINFO, &fb_fix);

	len = fb_fix.smem_len;
	off = (len + 0x0fff) & ~0x0fff;
	p = (unsigned long)mmap(0, fb_fix.mmio_len, PROT_READ|PROT_WRITE,
		MAP_SHARED, fd, off);
	p += GE_MMIO_OFFSET;
	(*geinfo)->mmio = (void *)p;

	ioctl(fd, GEIOGET_CHIP_ID, &id);
	(*geinfo)->id = id;
	(*geinfo)->config = 0;
	(*geinfo)->data = 0;
	(*geinfo)->gmp = NULL;
	(*geinfo)->priv = NULL;

	(*geinfo)->gmp = create_gmp(0, 0);

	return 0;
}

INLINE int ge_sys_exit(ge_info_t *geinfo, void *priv)
{
	struct fb_fix_screeninfo fb_fix;
	unsigned long p;

	IGNORE(priv);

	release_gmp(geinfo->gmp);
	release_ge_plugin(geinfo->plugin);

	ioctl(geinfo->fd, FBIOGET_FSCREENINFO, &fb_fix);

	p = (unsigned long)geinfo->mmio;
	p -= GE_MMIO_OFFSET;

	munmap((void *)p, fb_fix.mmio_len);
	close(geinfo->fd);

	free(geinfo);

	return 0;
}

INLINE int ge_get_chip_id(ge_info_t *geinfo, unsigned int *chip_id)
{
	*chip_id = geinfo->id;

	return *chip_id ? 0 : -1;
}

INLINE void ge_wait_sync_timeout(ge_info_t *geinfo, int timeout)
{
	ioctl(geinfo->fd, GEIO_WAIT_SYNC, timeout);
}

INLINE void ge_wait_sync(ge_info_t *geinfo)
{
	ge_wait_sync_timeout(geinfo, -1);
}

INLINE int ge_lock(ge_info_t *geinfo)
{
	int fd;
	int ret;

	fd = geinfo->fd;
	ret = ioctl(fd, GEIO_LOCK, 1);

	return ret;
}

INLINE int ge_unlock(ge_info_t *geinfo)
{
	int fd;
	int ret;

	fd = geinfo->fd;
	ret = ioctl(fd, GEIO_LOCK, 0);

	return ret;
}

INLINE int ge_trylock(ge_info_t *geinfo)
{
	int fd;
	int ret;

	fd = geinfo->fd;
	ret = ioctl(fd, GEIO_LOCK, 2);

	return ret;
}
#elif defined(__POST__)
static ge_info_t geinfo_static;

INLINE int ge_sys_init(ge_info_t **geinfo, void *priv)
{
	volatile ge_regs_t *regs;
	*geinfo = &geinfo_static;

	IGNORE(priv);

	(*geinfo)->fd = 0;
	(*geinfo)->mmio = (void *)(GE_MMIO_START + GE_MMIO_OFFSET);
	(*geinfo)->id = SCC_CHIP_ID;
	(*geinfo)->config = 0;
	(*geinfo)->data = 0;
	(*geinfo)->gmp = NULL;
	(*geinfo)->priv = NULL;

	regs = (ge_regs_t *)(*geinfo)->mmio;
	regs->ge_int_en = 0; /* disable interrupt */

	return 0;
}

INLINE int ge_sys_exit(ge_info_t *geinfo, void *priv)
{
	IGNORE(priv);

	if (geinfo->gmp) {
		release_gmp(geinfo->gmp);
		geinfo->gmp = NULL;
	}
	memset(geinfo, 0, sizeof(ge_info_t));

	return 0;
}

INLINE int ge_get_chip_id(ge_info_t *geinfo, unsigned int *chip_id)
{
	*chip_id = geinfo->id;

	return *chip_id ? 0 : -1;
}

INLINE void ge_wait_sync_timeout(ge_info_t *geinfo, int timeout)
{
	volatile ge_regs_t *regs;
	volatile int val;
	unsigned int msk = BIT8 | BIT9 | BIT19 | BIT20;

	regs = (ge_regs_t *)geinfo->mmio;

	if (!regs->ge_eng_en)
		return;

	val = timeout > 0 ? timeout * 0xffff : 0x00ffffff;
	while ((regs->ge_int_flag & msk) == 0 && val--);
	regs->ge_int_stat |= regs->ge_int_flag;
	regs->ge_int_flag = ~0;
	if (val < 0) {
		val = regs->ge_int_stat;
		regs->ge_int_stat = val | BIT20;
	}

	/*
	if (regs->ge_status && (regs->ge_int_stat & msk) == 0) {
		printf("%s: error. stat = %08x, irq_stat = %08x\n",
			__func__, regs->ge_status, regs->ge_int_stat);
	}
	*/
}

INLINE void ge_wait_sync(ge_info_t *geinfo)
{
	ge_wait_sync_timeout(geinfo, -1);
}

INLINE int ge_lock(ge_info_t *geinfo)
{
	return 0;
}

INLINE int ge_unlock(ge_info_t *geinfo)
{
	return 0;
}

INLINE int ge_trylock(ge_info_t *geinfo)
{
	return 0;
}
#endif

ge_info_t *create_ge_info(void)
{
	ge_info_t *geinfo;
	if (ge_sys_init(&geinfo, NULL) < 0)
		return NULL;
	return geinfo;
}

void release_ge_info(ge_info_t *geinfo)
{
	ge_sys_exit(geinfo, NULL);
}

/* PUT SYSTEM INDEPENDANT FUNCTIONS HERE */

INLINE int ge_set_src_csc(ge_info_t *geinfo, int cscid)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	switch (cscid) {
	case GE_CSC_DEFAULT:
		/* do nothing */
		break;
	case GE_CSC_RGB_YC_SDTV_16_235:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x132;
		regs->src_c2_coef = 0x259;
		regs->src_c3_coef = 0x75;
		regs->src_c4_coef = 0x1f50;
		regs->src_c5_coef = 0x1ea5;
		regs->src_c6_coef = 0x20b;
		regs->src_c7_coef = 0x20b;
		regs->src_c8_coef = 0x1e4a;
		regs->src_c9_coef = 0x1fab;
		regs->src_coef_i = 1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SDTV_0_255:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x107;
		regs->src_c2_coef = 0x204;
		regs->src_c3_coef = 0x64;
		regs->src_c4_coef = 0x1f68;
		regs->src_c5_coef = 0x1ed6;
		regs->src_c6_coef = 0x1c2;
		regs->src_c7_coef = 0x1c2;
		regs->src_c8_coef = 0x1e78;
		regs->src_c9_coef = 0x1fb7;
		regs->src_coef_i = 0x20;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_HDTV_16_235:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0xda;
		regs->src_c2_coef = 0x2dc;
		regs->src_c3_coef = 0x4a;
		regs->src_c4_coef = 0x1f88;
		regs->src_c5_coef = 0x1e6d;
		regs->src_c6_coef = 0x20b;
		regs->src_c7_coef = 0x20b;
		regs->src_c8_coef = 0x1e25;
		regs->src_c9_coef = 0x1fd0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_HDTV_0_255:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0xbb;
		regs->src_c2_coef = 0x275;
		regs->src_c3_coef = 0x3f;
		regs->src_c4_coef = 0x1f99;
		regs->src_c5_coef = 0x1ea6;
		regs->src_c6_coef = 0x1c2;
		regs->src_c7_coef = 0x1c2;
		regs->src_c8_coef = 0x1e67;
		regs->src_c9_coef = 0x1fd7;
		regs->src_coef_i = 0x21;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_JFIF_0_255:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x132;
		regs->src_c2_coef = 0x259;
		regs->src_c3_coef = 0x75;
		regs->src_c4_coef = 0x1f53;
		regs->src_c5_coef = 0x1ead;
		regs->src_c6_coef = 0x200;
		regs->src_c7_coef = 0x200;
		regs->src_c8_coef = 0x1e53;
		regs->src_c9_coef = 0x1fad;
		regs->src_coef_i = 0x1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SMPTE_170M:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x132;
		regs->src_c2_coef = 0x259;
		regs->src_c3_coef = 0x75;
		regs->src_c4_coef = 0x1f50;
		regs->src_c5_coef = 0x1ea5;
		regs->src_c6_coef = 0x20b;
		regs->src_c7_coef = 0x20b;
		regs->src_c8_coef = 0x1e4a;
		regs->src_c9_coef = 0x1fab;
		regs->src_coef_i = 1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SMPTE_240M:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0xd9;
		regs->src_c2_coef = 0x2ce;
		regs->src_c3_coef = 0x59;
		regs->src_c4_coef = 0x2f89;
		regs->src_c5_coef = 0x1e77;
		regs->src_c6_coef = 0x200;
		regs->src_c7_coef = 0x200;
		regs->src_c8_coef = 0x1e38;
		regs->src_c9_coef = 0x1fc8;
		regs->src_coef_i = 1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_RGB_BYPASS:
		regs->src_csc_mode = 0;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0;
		regs->src_c6_coef = 0;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 0x101;
		regs->src_coef_k = 0x101;
		break;
	case GE_CSC_YC_RGB_SDTV_16_235:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x57c;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0x1ea8;
		regs->src_c6_coef = 0x1d35;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0x6ee;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SDTV_0_255:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 1;
		regs->src_c1_coef = 0x4a8;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x662;
		regs->src_c4_coef = 0x4a8;
		regs->src_c5_coef = 0x1e70;
		regs->src_c6_coef = 0x1cbf;
		regs->src_c7_coef = 0x4a8;
		regs->src_c8_coef = 0x812;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_HDTV_16_235:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x629;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0x1f45;
		regs->src_c6_coef = 0x1e2a;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0x744;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_HDTV_0_255:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 1;
		regs->src_c1_coef = 0x4a8;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x72c;
		regs->src_c4_coef = 0x4a8;
		regs->src_c5_coef = 0x1f26;
		regs->src_c6_coef = 0x1ddd;
		regs->src_c7_coef = 0x4a8;
		regs->src_c8_coef = 0x876;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_JFIF_0_255:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x59c;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0x1ea0;
		regs->src_c6_coef = 0x1d25;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0x717;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SMPTE_170M:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x57c;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0x1ea8;
		regs->src_c6_coef = 0x1d35;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0x6ee;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SMPTE_240M:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 0x400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0x64d;
		regs->src_c4_coef = 0x400;
		regs->src_c5_coef = 0x1f19;
		regs->src_c6_coef = 0x1e00;
		regs->src_c7_coef = 0x400;
		regs->src_c8_coef = 0x74f;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	case GE_CSC_YC_BYPASS:
		regs->src_csc_mode = 1;
		regs->src_y_sub_16_en = 0;
		regs->src_c1_coef = 400;
		regs->src_c2_coef = 0;
		regs->src_c3_coef = 0;
		regs->src_c4_coef = 400;
		regs->src_c5_coef = 0;
		regs->src_c6_coef = 0;
		regs->src_c7_coef = 400;
		regs->src_c8_coef = 0;
		regs->src_c9_coef = 0;
		regs->src_coef_i = 1;
		regs->src_coef_j = 1;
		regs->src_coef_k = 1;
		break;
	}

	return 0;
}

INLINE int ge_set_dst_csc(ge_info_t *geinfo, int cscid)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	switch (cscid) {
	case GE_CSC_DEFAULT:
		/* do nothing */
		break;
	case GE_CSC_RGB_YC_SDTV_16_235:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x132;
		regs->des_c2_coef = 0x259;
		regs->des_c3_coef = 0x75;
		regs->des_c4_coef = 0x1f50;
		regs->des_c5_coef = 0x1ea5;
		regs->des_c6_coef = 0x20b;
		regs->des_c7_coef = 0x20b;
		regs->des_c8_coef = 0x1e4a;
		regs->des_c9_coef = 0x1fab;
		regs->des_coef_i = 1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SDTV_0_255:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x107;
		regs->des_c2_coef = 0x204;
		regs->des_c3_coef = 0x64;
		regs->des_c4_coef = 0x1f68;
		regs->des_c5_coef = 0x1ed6;
		regs->des_c6_coef = 0x1c2;
		regs->des_c7_coef = 0x1c2;
		regs->des_c8_coef = 0x1e78;
		regs->des_c9_coef = 0x1fb7;
		regs->des_coef_i = 0x20;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_HDTV_16_235:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0xda;
		regs->des_c2_coef = 0x2dc;
		regs->des_c3_coef = 0x4a;
		regs->des_c4_coef = 0x1f88;
		regs->des_c5_coef = 0x1e6d;
		regs->des_c6_coef = 0x20b;
		regs->des_c7_coef = 0x20b;
		regs->des_c8_coef = 0x1e25;
		regs->des_c9_coef = 0x1fd0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_HDTV_0_255:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0xbb;
		regs->des_c2_coef = 0x275;
		regs->des_c3_coef = 0x3f;
		regs->des_c4_coef = 0x1f99;
		regs->des_c5_coef = 0x1ea6;
		regs->des_c6_coef = 0x1c2;
		regs->des_c7_coef = 0x1c2;
		regs->des_c8_coef = 0x1e67;
		regs->des_c9_coef = 0x1fd7;
		regs->des_coef_i = 0x21;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_JFIF_0_255:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x132;
		regs->des_c2_coef = 0x259;
		regs->des_c3_coef = 0x75;
		regs->des_c4_coef = 0x1f53;
		regs->des_c5_coef = 0x1ead;
		regs->des_c6_coef = 0x200;
		regs->des_c7_coef = 0x200;
		regs->des_c8_coef = 0x1e53;
		regs->des_c9_coef = 0x1fad;
		regs->des_coef_i = 0x1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SMPTE_170M:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x132;
		regs->des_c2_coef = 0x259;
		regs->des_c3_coef = 0x75;
		regs->des_c4_coef = 0x1f50;
		regs->des_c5_coef = 0x1ea5;
		regs->des_c6_coef = 0x20b;
		regs->des_c7_coef = 0x20b;
		regs->des_c8_coef = 0x1e4a;
		regs->des_c9_coef = 0x1fab;
		regs->des_coef_i = 1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_YC_SMPTE_240M:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0xd9;
		regs->des_c2_coef = 0x2ce;
		regs->des_c3_coef = 0x59;
		regs->des_c4_coef = 0x2f89;
		regs->des_c5_coef = 0x1e77;
		regs->des_c6_coef = 0x200;
		regs->des_c7_coef = 0x200;
		regs->des_c8_coef = 0x1e38;
		regs->des_c9_coef = 0x1fc8;
		regs->des_coef_i = 1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_RGB_BYPASS:
		regs->des_csc_mode = 0;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0;
		regs->des_c6_coef = 0;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 0x101;
		regs->des_coef_k = 0x101;
		break;
	case GE_CSC_YC_RGB_SDTV_16_235:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x57c;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0x1ea8;
		regs->des_c6_coef = 0x1d35;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0x6ee;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SDTV_0_255:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 1;
		regs->des_c1_coef = 0x4a8;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x662;
		regs->des_c4_coef = 0x4a8;
		regs->des_c5_coef = 0x1e70;
		regs->des_c6_coef = 0x1cbf;
		regs->des_c7_coef = 0x4a8;
		regs->des_c8_coef = 0x812;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_HDTV_16_235:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x629;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0x1f45;
		regs->des_c6_coef = 0x1e2a;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0x744;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_HDTV_0_255:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 1;
		regs->des_c1_coef = 0x4a8;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x72c;
		regs->des_c4_coef = 0x4a8;
		regs->des_c5_coef = 0x1f26;
		regs->des_c6_coef = 0x1ddd;
		regs->des_c7_coef = 0x4a8;
		regs->des_c8_coef = 0x876;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_JFIF_0_255:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x59c;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0x1ea0;
		regs->des_c6_coef = 0x1d25;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0x717;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SMPTE_170M:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x57c;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0x1ea8;
		regs->des_c6_coef = 0x1d35;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0x6ee;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_RGB_SMPTE_240M:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 0x400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0x64d;
		regs->des_c4_coef = 0x400;
		regs->des_c5_coef = 0x1f19;
		regs->des_c6_coef = 0x1e00;
		regs->des_c7_coef = 0x400;
		regs->des_c8_coef = 0x74f;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	case GE_CSC_YC_BYPASS:
		regs->des_csc_mode = 1;
		regs->des_y_sub_16_en = 0;
		regs->des_c1_coef = 400;
		regs->des_c2_coef = 0;
		regs->des_c3_coef = 0;
		regs->des_c4_coef = 400;
		regs->des_c5_coef = 0;
		regs->des_c6_coef = 0;
		regs->des_c7_coef = 400;
		regs->des_c8_coef = 0;
		regs->des_c9_coef = 0;
		regs->des_coef_i = 1;
		regs->des_coef_j = 1;
		regs->des_coef_k = 1;
		break;
	}

	return 0;
}

static int ge_set_src_pixelformat_3445(ge_info_t *geinfo, unsigned int pixelformat)
{
	volatile struct ge_regs_3445 *regs;
	int ret = 0;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (pixelformat) {
	case GSPF_RGB16:
		regs->src_indep_mode = 0x14; /* 10100b */
		break;
	case GSPF_RGB555:
		regs->src_indep_mode = 0x15; /* 10101b */
		break;
	case GSPF_RGB454:
		regs->src_indep_mode = 0x16; /* 10110b */
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		regs->src_indep_mode = 0x1c; /* 11100b */
		break;
	default:
		regs->src_indep_mode = 0;
		ret = -1;
	}

	return ret;
}

static int ge_set_src_pixelformat_3481(ge_info_t *geinfo, unsigned int pixelformat)
{
	volatile ge_regs_t *regs;
	int ret = 0;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->src_csc_en = 0;

	switch (pixelformat) {
	case GSPF_RGB16:
		regs->src_yuv_en = 0;
		regs->src_color_depth = 1; /* 16 bpp */
		regs->src_hm_sel = 0;      /* 565 */
		regs->src_input_sel = 0;
		break;
	case GSPF_RGB555:
		regs->src_yuv_en = 0;
		regs->src_color_depth = 1; /* 16 bpp */
		regs->src_hm_sel = 1;      /* 555 */
		regs->src_input_sel = 0;
		break;
	case GSPF_RGB454:
		regs->src_yuv_en = 0;
		regs->src_color_depth = 1; /* 16 bpp */
		regs->src_hm_sel = 2;      /* 454 */
		regs->src_input_sel = 0;
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		regs->src_yuv_en = 0;
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 0;
		break;
	case GSPF_YUV420SP:
		ge_set_src_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->src_yuv_en = 1;
		regs->src_fmt444 = 0;
		regs->src_vfmt = 1;
		regs->src_csc_en = 1;
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 0;
		break;
	case GSPF_YUV422SP:
		ge_set_src_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->src_yuv_en = 1;
		regs->src_fmt444 = 0;
		regs->src_vfmt = 0;
		regs->src_csc_en = 1;
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 0;
		break;
	case GSPF_YUV444SP:
		ge_set_src_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->src_yuv_en = 1;
		regs->src_fmt444 = 1;
		regs->src_csc_en = 1;
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 0;
		break;
	case GSPF_VPU:
		ge_set_src_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->src_yuv_en = 0;
		regs->src_csc_en = 1;
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 1;
		break;
	default:
		regs->src_color_depth = 3; /* 32 bpp */
		regs->src_input_sel = 0;
		ret = -1;
	}

	return ret;
}

INLINE int ge_set_src_pixelformat(ge_info_t *geinfo, unsigned int pixelformat)
{
	unsigned int major;
	unsigned int minor;

	major = geinfo->id >> 16;
	minor = geinfo->id & 0xffff;

	IGNORE(minor);

	if (major == 0x3445) /* WM3445 B0 */
		return ge_set_src_pixelformat_3445(geinfo, pixelformat);

	return ge_set_src_pixelformat_3481(geinfo, pixelformat);
}

static int ge_set_dst_pixelformat_3445(ge_info_t *geinfo, unsigned int pixelformat)
{
	volatile struct ge_regs_3445 *regs;
	int ret = 0;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (pixelformat) {
	case GSPF_LUT8:
		regs->color_depth = 0;
		break;
	case GSPF_RGB16:
		regs->color_depth = 1;
		regs->hm_sel = 0;
		break;
	case GSPF_RGB555:
		regs->color_depth = 1;
		regs->hm_sel = 1;
		break;
	case GSPF_RGB454:
		regs->color_depth = 1;
		regs->hm_sel = 2;
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		regs->color_depth = 3;
		break;
	default:
		ret = -1;
	}

	return ret;
}

static int ge_set_dst_pixelformat_3481(ge_info_t *geinfo, unsigned int pixelformat)
{
	volatile ge_regs_t *regs;
	int ret = 0;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->des_csc_en = 0;

	switch (pixelformat) {
	case GSPF_RGB16:
		regs->des_yuv_en = 0;
		regs->des_color_depth = 1; /* 16 bpp */
		regs->des_hm_sel = 0;      /* 565 */
		break;
	case GSPF_RGB555:
		regs->des_yuv_en = 0;
		regs->des_color_depth = 1; /* 16 bpp */
		regs->des_hm_sel = 1;      /* 555 */
		break;
	case GSPF_RGB454:
		regs->des_yuv_en = 0;
		regs->des_color_depth = 1; /* 16 bpp */
		regs->des_hm_sel = 2;      /* 565 */
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		regs->des_yuv_en = 0;
		regs->des_color_depth = 3; /* 32 bpp */
		break;
	case GSPF_YUV420SP:
		ge_set_dst_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->des_yuv_en = 1;
		regs->des_fmt444 = 0;
		regs->des_vfmt = 1;
		regs->des_csc_en = 1;
		regs->des_color_depth = 3; /* 32 bpp */
		break;
	case GSPF_YUV422SP:
		ge_set_dst_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->des_yuv_en = 1;
		regs->des_fmt444 = 0;
		regs->des_vfmt = 0;
		regs->des_csc_en = 1;
		regs->des_color_depth = 3; /* 32 bpp */
		break;
	case GSPF_YUV444SP:
		ge_set_dst_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
		regs->des_yuv_en = 1;
		regs->des_fmt444 = 1;
		regs->des_csc_en = 1;
		regs->des_color_depth = 3; /* 32 bpp */
		break;
	case GSPF_VPU:
		/* N/A. Only source path supports VPU */
	default:
		regs->des_yuv_en = 0;
		regs->des_csc_en = 0;
		regs->des_color_depth = 3; /* 32 bpp */
		ret = -1;
	}

	return ret;
}

INLINE int ge_set_dst_pixelformat(ge_info_t *geinfo, unsigned int pixelformat)
{
	unsigned int major = geinfo->id >> 16;

	if (major == 0x3445) /* WM3445 B0 */
		return ge_set_dst_pixelformat_3445(geinfo, pixelformat);

	return ge_set_dst_pixelformat_3481(geinfo, pixelformat);
}

INLINE int ge_set_dw_pixelformat(ge_info_t *geinfo, unsigned int pixelformat)
{
	volatile ge_regs_t *regs;
	unsigned int major;
	unsigned int minor;
	int ret = 0;

	regs = (ge_regs_t *)geinfo->mmio;

	major = geinfo->id >> 16;
	minor = geinfo->id & 0xffff;

	IGNORE(minor);

	if (major == 0x3445) /* WM3445 B0 */
		return 0;

	/* IGS: 0:888, 1:555, 2:666, 3:565, 4:bypass, 5:454 */
	regs->dw_yuv_en = 0;

	switch (pixelformat) {
	case GSPF_RGB16:
		regs->src_igs_mode = 3;   /* 565 */
		regs->des_igs_mode = 3;   /* 565 */
		regs->dw_color_depth = 1; /* 16 bpp */
		regs->dw_hm_sel = 0;      /* 565 */
		break;
	case GSPF_RGB555:
		regs->src_igs_mode = 1;   /* 555 */
		regs->des_igs_mode = 1;   /* 555 */
		regs->dw_color_depth = 1; /* 16 bpp */
		regs->dw_hm_sel = 1;      /* 555 */
		break;
	case GSPF_RGB454:
		regs->src_igs_mode = 5;   /* 454 */
		regs->des_igs_mode = 5;   /* 454 */
		regs->dw_color_depth = 1; /* 16 bpp */
		regs->dw_hm_sel = 2;      /* 454 */
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		regs->src_igs_mode = 0;   /* 888 */
		regs->des_igs_mode = 0;   /* 888 */
		regs->dw_color_depth = 3; /* 32 bpp */
		break;
	case GSPF_YUV420SP:
		regs->src_igs_mode = 0;   /* 888 */
		regs->des_igs_mode = 0;   /* 888 */
		regs->dw_color_depth = 3; /* 32 bpp */
		regs->dw_yuv_en = 1;
		regs->dw_fmt444 = 0;
		regs->dw_vfmt = 1;
		break;
	case GSPF_YUV422SP:
		regs->src_igs_mode = 0;   /* 888 */
		regs->des_igs_mode = 0;   /* 888 */
		regs->dw_color_depth = 3; /* 32 bpp */
		regs->dw_yuv_en = 1;
		regs->dw_fmt444 = 0;
		regs->dw_vfmt = 0;
		break;
	case GSPF_YUV444SP:
		regs->src_igs_mode = 0;   /* 888 */
		regs->des_igs_mode = 0;   /* 888 */
		regs->dw_color_depth = 3; /* 32 bpp */
		regs->dw_yuv_en = 1;
		regs->dw_fmt444 = 1;
		regs->dw_vfmt = 1;
		break;
	case GSPF_VPU:
		regs->src_igs_mode = 0;   /* 888 */
		regs->des_igs_mode = 0;   /* 888 */
		regs->dw_color_depth = 3; /* 32 bpp */
		ret = -1;
		break;
	default:
		ret = -1;
	}

	return ret;
}

INLINE int ge_set_direct_write(ge_info_t *geinfo, const ge_surface_t *dw)
{
	volatile ge_regs_t *regs;
	unsigned int major;

	regs = (ge_regs_t *)geinfo->mmio;
	major = geinfo->id >> 16;

	if (major == 0x3445) /* WM3445 B0 */
		return 0;

	regs->dw_baddr = dw->addr;
	regs->dw_c_baddr = dw->addr + dw->planesize[0];
	regs->dw_disp_w = dw->xres_virtual - 1;
	regs->dw_disp_h = dw->yres_virtual - 1;

	regs->dw_x_start = dw->x;
	regs->dw_y_start = dw->y;
	regs->dw_width = dw->xres - 1;
	regs->dw_height = dw->yres - 1;

	return ge_set_dw_pixelformat(geinfo, dw->pixelformat);
}

static void fix_src_rmif(ge_info_t *geinfo, const ge_surface_t *src)
{
	unsigned int major = geinfo->id >> 16;
	volatile ge_regs_t *regs;
	unsigned int c;

	regs = (ge_regs_t *)geinfo->mmio;

	if (major >= 0x3481) {
		switch (src->pixelformat) {
		case GSPF_YUV420SP:
		case GSPF_YUV422SP:
			c = regs->src_x_start + regs->src_width + 1;
			regs->src_req_sel = 1;
			regs->src_y_req_num = c & 0x3f ? (c >> 6) + 2 : (c >> 6) + 1;
			regs->src_c_req_num = (c >> 6) + 2;
			break;
		default:
			regs->src_req_sel = 0;
			break;
		}
	}
}

static void fix_dst_rmif(ge_info_t *geinfo, const ge_surface_t *dst)
{
	unsigned int major = geinfo->id >> 16;
	volatile ge_regs_t *regs;
	unsigned int c;

	regs = (ge_regs_t *)geinfo->mmio;

	if (major >= 0x3481) {
		switch (dst->pixelformat) {
		case GSPF_YUV420SP:
		case GSPF_YUV422SP:
			c = regs->des_x_start + regs->des_width + 1;
			regs->des_req_sel = 1;
			regs->des_y_req_num = c & 0x3f ? (c >> 6) + 2 : (c >> 6) + 1;
			regs->des_c_req_num = (c >> 6) + 2;
			break;
		default:
			regs->des_req_sel = 0;
			break;
		}
	}
}

INLINE int ge_set_destination(ge_info_t *geinfo, const ge_surface_t *dst)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->des_baddr = dst->addr;
	regs->des_c_baddr = dst->addr + dst->planesize[0];
	regs->des_disp_w = dst->xres_virtual - 1;
	regs->des_disp_h = dst->yres_virtual - 1;

	regs->des_x_start = dst->x;
	regs->des_y_start = dst->y;
	regs->des_width = dst->xres - 1;
	regs->des_height = dst->yres - 1;

	ge_set_dst_pixelformat(geinfo, dst->pixelformat);

	fix_dst_rmif(geinfo, dst);

	return ge_set_direct_write(geinfo, dst);
}

INLINE int ge_set_source(ge_info_t *geinfo, const ge_surface_t *src)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->src_baddr = src->addr;
	regs->src_c_baddr = src->addr + src->planesize[0];
	regs->src_disp_w = src->xres_virtual - 1;
	regs->src_disp_h = src->yres_virtual - 1;

	regs->src_x_start = src->x;
	regs->src_y_start = src->y;
	regs->src_width = src->xres - 1;
	regs->src_height = src->yres - 1;

	ge_set_src_pixelformat(geinfo, src->pixelformat);

	fix_src_rmif(geinfo, src);

	return 0;
}

INLINE int ge_set_govr_source(ge_info_t *geinfo,
			      const ge_surface_t *src,
			      int x,
			      int y)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	if (src) {
		ge_set_source(geinfo, src);
		regs->src_igs_mode = 0;   /* 888 */
		regs->govr_src_x_start = x;
		regs->govr_src_y_start = y;
		/* regs->govr_src_en = src->pixelformat == GSPF_VPU ? 0 : 1; */
		regs->govr_src_en = 1;
	} else
		regs->govr_src_en = 0;

	return 0;
}

INLINE int ge_set_govr_destination(ge_info_t *geinfo,
				   const ge_surface_t *dst,
				   int x,
				   int y)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	if (dst) {
		ge_set_destination(geinfo, dst);
		regs->des_igs_mode = 0;   /* 888 */
		regs->govr_des_x_start = x;
		regs->govr_des_y_start = y;
		/* regs->govr_des_en = dst->pixelformat == GSPF_VPU ? 0 : 1; */
		regs->govr_des_en = 1;
	} else
		regs->govr_des_en = 0;

	return 0;
}

INLINE int ge_set_govr_size(ge_info_t *geinfo, int w, int h)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;
	regs->dw_color_depth = 3; /* 32 bpp */
	regs->dw_disp_w = w - 1;
	regs->dw_disp_h = h - 1;

	return 0;
}

INLINE int ge_set_mask(ge_info_t *geinfo, ge_surface_t *src)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->mask_baddr = src->addr;
	regs->mask_disp_w = src->xres_virtual - 1;
	regs->mask_disp_h = src->yres_virtual - 1;

	regs->mask_x_start = src->x;
	regs->mask_y_start = src->y;
	regs->mask_width = src->xres - 1;
	regs->mask_height = src->yres - 1;

	return 0;
}

INLINE int ge_set_command(ge_info_t *geinfo, unsigned int cmd, unsigned int rop)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->ge_int_stat = 0;
	regs->ge_command = cmd;
	regs->rop_code = rop;	/* cc = s->d, 0f = p->d */
	regs->ge_eng_en = 1;
	ge_mb();
	regs->ge_fire = 1;

	return 0;
}

INLINE unsigned int ge_get_color(ge_info_t *geinfo,
	unsigned int r, unsigned int g, unsigned int b, unsigned int a,
	unsigned int pixfmt)
{
	unsigned int color;

	IGNORE(geinfo);

	switch (pixfmt) {
	case GSPF_LUT8:
		color = a;
		break;
	case GSPF_RGB16:
		color = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
		break;
	case GSPF_RGB555:
		color = ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3);
		break;
	case GSPF_RGB454:
		color = ((r >> 4) << 9) | ((g >> 3) << 4) | (b >> 4);
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		color = (a << 24) | (r << 16) | (g << 8) | (b) ;
		break;
	default:
		color = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
		break;
	}

	return color;
}

INLINE void ge_set_color(ge_info_t *geinfo,
	unsigned int r, unsigned int g, unsigned int b, unsigned int a,
	unsigned int pixfmt)
{
	volatile ge_regs_t *regs;
	unsigned int color;

	color = ge_get_color(geinfo, r, g, b, a, pixfmt);

	regs = (ge_regs_t *)geinfo->mmio;
	regs->pat0_color = color;
}

INLINE void ge_set_sck(ge_info_t *geinfo,
	unsigned int r, unsigned int g, unsigned int b, unsigned int a,
	unsigned int pixfmt)
{
	volatile ge_regs_t *regs;
	unsigned int color;

	color = ge_get_color(geinfo, r, g, b, a, pixfmt);

	regs = (ge_regs_t *)geinfo->mmio;
	regs->src_ck = color;
	regs->ck_sel |= BIT2;
}

INLINE void ge_set_dck(ge_info_t *geinfo,
	unsigned int r, unsigned int g, unsigned int b, unsigned int a,
	unsigned int pixfmt)
{
	volatile ge_regs_t *regs;
	unsigned int color;

	color = ge_get_color(geinfo, r, g, b, a, pixfmt);

	regs = (ge_regs_t *)geinfo->mmio;
	regs->des_ck = color;
	regs->ck_sel |= BIT3 | BIT1;
}

INLINE int ge_cmd_blit(ge_info_t *geinfo)
{
	return ge_set_command(geinfo, GECMD_BLIT, 0xcc);
}

INLINE int ge_cmd_fillrect(ge_info_t *geinfo)
{
	return ge_set_command(geinfo, GECMD_BLIT, 0xf0);
}

INLINE int ge_cmd_rotate(ge_info_t *geinfo, unsigned int arc)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	switch (arc % 360) {
	case 0:
		regs->rotate_mode = 0;
		break;
	case 90:
		regs->rotate_mode = 1;
		break;
	case 180:
		regs->rotate_mode = 2;
		break;
	case 270:
		regs->rotate_mode = 3;
		break;
	default:
		break;
	}
	ge_set_command(geinfo, GECMD_ROTATE, 0xcc);

	ge_wait_sync(geinfo); /* Required. */

	return 0;
}

INLINE int ge_cmd_mirror(ge_info_t *geinfo, int mode)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->mirror_mode = mode & BIT0;

	ge_set_command(geinfo, GECMD_MIRROR, 0xcc);
	ge_wait_sync(geinfo); /* Required. */

	return 0;
}

/* AMX barebone functions */

/* depercated */
INLINE int amx_show_surface(ge_info_t *geinfo,
	int id, ge_surface_t *s, int x, int y)
{
	volatile struct ge_regs_3445 *regs;
	volatile unsigned int *gov_regs;
	unsigned int cd; /* color depth */
	unsigned int hm; /* hi color mode */
	unsigned int gov_dspcr;

	if (GSPF_YUV(s->pixelformat))
		return -1;

	cd = GSPF_BYTES_PER_PIXEL(s->pixelformat) - 1;
	hm = GSPF_VARIANT(s->pixelformat);

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	gov_regs = (unsigned int *)geinfo->mmio;
	gov_regs -= 64;
	gov_dspcr = gov_regs[7];

	if (gov_dspcr) {
		/* if gov was initialized ... */
		regs->disp_x_end = gov_dspcr & 0x7ff;
		regs->disp_y_end = gov_dspcr >> 16;
	} else {
		/* if gov is not initialized yet ... */
		regs->disp_x_end = s->xres_virtual - 1;
		regs->disp_y_end = s->yres_virtual - 1;
	}

	/*
	 * Register g1_yuv_mode_en was implemented since WM3445 B0.
	 * It returns zero on chips before WM3445 B0.
	 */

	if (id == 0) {
		/* G1 */
		regs->g1_cd = regs->g1_yuv_mode_en ? 3 : cd;
		regs->g1_amx_hm = hm;

		/* If FG being used, use BG. */
		if (regs->g1_fb_sel == 0) {
			regs->g1_bg_addr = s->addr;
			regs->g1_fb_sel = 1;
		} else {
			regs->g1_fg_addr = s->addr;
			regs->g1_fb_sel = 0;
		}

		regs->g1_fbw = s->xres_virtual;
		regs->g1_hcrop = s->x;
		regs->g1_vcrop = s->y;
		regs->g1_x_start =  x;
		regs->g1_x_end = x + s->xres - 1;
		regs->g1_y_start = y;
		regs->g1_y_end = y + s->yres - 1;
		regs->g1_amx_en = 1;
	} else {
		/* G2 */
		regs->g2_cd = regs->g2_yuv_mode_en ? 3 : cd;
		regs->g2_amx_hm = hm;

		/* If FG being used, use BG. */
		if (regs->g2_fb_sel == 0) {
			regs->g2_bg_addr = s->addr;
			regs->g2_fb_sel = 1;
		} else {
			regs->g2_fg_addr = s->addr;
			regs->g2_fb_sel = 0;
		}

		regs->g2_fbw = s->xres_virtual;
		regs->g2_hcrop = s->x;
		regs->g2_vcrop = s->y;
		regs->g2_x_start =  x;
		regs->g2_x_end = x + s->xres - 1;
		regs->g2_y_start = y;
		regs->g2_y_end = y + s->yres - 1;
		regs->g2_amx_en = 1;
	}

	return 0;
}

/* depercated */
INLINE int amx_get_surface(ge_info_t *geinfo, int id, ge_surface_t *s)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	/* Since AMX will be abandoned soon after WM3445, instead of
	 * supporting all pixel formats, we only check RGB16/RGB32 here.
	 */
	if (id == 0 && regs->g1_yuv_mode_en)
		return -1;
	if (id == 1 && regs->g2_yuv_mode_en)
		return -1;

	/*
	 * Register g1_yuv_mode_en was implemented since WM3445 B0.
	 * It returns zero on chips before WM3445 B0.
	 */

	if (id == 0) {
		/* G1 */
		s->addr = regs->g1_fb_sel ?
			regs->g1_bg_addr : regs->g1_fg_addr;
		s->x = regs->g1_hcrop;
		s->y = regs->g1_vcrop;
		s->xres = regs->g1_x_end - regs->g1_x_start + 1;
		s->yres = regs->g1_y_end - regs->g1_y_start + 1;
		s->xres_virtual = regs->g1_fbw;
		s->yres_virtual = s->yres;
	} else {
		/* G2 */
		s->addr = regs->g2_fb_sel ?
			regs->g2_bg_addr : regs->g2_fg_addr;
		s->x = regs->g2_hcrop;
		s->y = regs->g2_vcrop;
		s->xres = regs->g2_x_end - regs->g2_x_start + 1;
		s->yres = regs->g2_y_end - regs->g2_y_start + 1;
		s->xres_virtual = regs->g2_fbw;
		s->yres_virtual = s->yres;
	}

	if (id == 0)
		s->pixelformat = regs->g1_cd == 1 ? GSPF_RGB16 : GSPF_RGB32;
	if (id == 1)
		s->pixelformat = regs->g2_cd == 1 ? GSPF_RGB16 : GSPF_RGB32;

	return 0;
}

/* depercated */
INLINE int amx_hide_surface(ge_info_t *geinfo, int id)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (id) {
	case 0:
		regs->g1_amx_en = 0;
		break;
	case 1:
		regs->g2_amx_en = 0;
		break;
	default:
		break;
	}
	return 0;
}

INLINE int amx_set_colorkey(ge_info_t *geinfo, int id, int enable,
	unsigned int r, unsigned int g, unsigned int b, unsigned int pixfmt)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (pixfmt) {
	case GSPF_RGB16:
		r &= ~0x7;
		g &= ~0x3;
		b &= ~0x7;
		break;
	case GSPF_RGB555:
		r &= ~0x7;
		g &= ~0x7;
		b &= ~0x7;
		break;
	case GSPF_RGB454:
		r &= ~0xf;
		g &= ~0x7;
		b &= ~0xf;
		break;
	}

	switch (id) {
	case 0:
		regs->g1_ck_en = enable;
		regs->g1_c_key = enable ?
			((r << 16) | (g << 8) | (b)) : 0;
		break;
	case 1:
		regs->g2_ck_en = enable;
		regs->g2_c_key = enable ?
			((r << 16) | (g << 8) | (b)) : 0;
		break;
	default:
		break;
	}

	return 0;
}

INLINE int amx_set_alpha_3445(ge_info_t *geinfo, unsigned int alpha)
{
	volatile struct ge_regs_3445 *regs;

	alpha &= 0xff;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	regs->ge_amx_ctl = BIT4 | BIT3;
	regs->ge_fix_apa = 0xffff | alpha << 24;
	regs->ge_ck_apa = BIT10;

	regs->ge_amx2_ctl = BIT0;
	regs->ge_fix2_apa = 0xff;
	regs->ge_ck2_apa = BIT11 | BIT7 | BIT3;

	amx_enable_pixel_alpha_3445(geinfo, 0, 0);

	return 0;
}

INLINE int amx_enable_pixel_alpha_3445(ge_info_t *geinfo, int g1_en, int g2_en)
{
	/* Not updated */
	volatile struct ge_regs_3445 *regs;
	unsigned int type;
	unsigned int ge_amx_ctl;
	unsigned int ge_amx2_ctl;

	type = g1_en | (g2_en << 1);
	regs = (struct ge_regs_3445 *)geinfo->mmio;
	ge_amx_ctl = regs->ge_amx_ctl;
	ge_amx2_ctl = regs->ge_amx2_ctl;

	switch (type) {
	case 0:
		/* disable pixel alpha */
		ge_amx_ctl &= ~(BIT0 | BIT1 | BIT2);
		ge_amx2_ctl |= BIT2 | BIT4 | BIT6;
		break;
	case 1:
		/* enable pixel alpha for G1 only */
		ge_amx_ctl &= ~BIT3;
		ge_amx_ctl |= BIT0 | BIT2;
		ge_amx2_ctl &= ~(BIT2 | BIT6);
		ge_amx2_ctl |= BIT3 | BIT4 | BIT7;
		break;
	case 2:
		/* enable pixel alpha for G2 only */
		ge_amx_ctl &= ~BIT0;
		ge_amx_ctl |= BIT1 | BIT2 | BIT3 | BIT4;
		ge_amx2_ctl &= ~BIT4;
		ge_amx2_ctl |= BIT2 | BIT5 | BIT6;
		break;
	case 3:
		/* enable pixel alpha */
		ge_amx_ctl &= ~BIT5;
		ge_amx_ctl |= BIT0 | BIT1 | BIT2 | BIT3 | BIT4;
		ge_amx2_ctl &= ~(BIT2 | BIT4 | BIT6);
		ge_amx2_ctl |= BIT3 | BIT5 | BIT7;
		break;
	default:
		break;
	}

	regs->ge_amx_ctl = ge_amx_ctl;
	regs->ge_amx2_ctl = ge_amx2_ctl;

	return 0;
}

INLINE int amx_enable_pixel_alpha(ge_info_t *geinfo, int g1_en, int g2_en)
{
	amx_enable_pixel_alpha_3445(geinfo, g1_en, g2_en);

	return 0;
}

INLINE int amx_set_alpha(ge_info_t *geinfo, int id, unsigned int alpha)
{
	alpha &= 0xff;

	if (id)
		alpha = 0xff - alpha;

	amx_set_alpha_3445(geinfo, alpha);

	return 0;
}

INLINE int amx_sync(ge_info_t *geinfo)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;
	regs->ge_reg_sel = 0; /* select level1 registers */
	regs->ge_reg_upd = 1; /* update level2 registers */

	return 0;
}

INLINE int amx_set_csc_basic(ge_info_t *geinfo, int cscid)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (cscid) {
	case AMX_CSC_DEFAULT:
		/* do nothing */
		break;
	case AMX_CSC_RGB_YC_SDTV_16_235:
		regs->c1_coef = 0x132;
		regs->c2_coef = 0x259;
		regs->c3_coef = 0x75;
		regs->c4_coef = 0x1f50;
		regs->c5_coef = 0x1ea5;
		regs->c6_coef = 0x20b;
		regs->c7_coef = 0x20b;
		regs->c8_coef = 0x1e4a;
		regs->c9_coef = 0x1fab;
		regs->coef_i = 1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_SDTV_0_255:
		regs->c1_coef = 0x107;
		regs->c2_coef = 0x204;
		regs->c3_coef = 0x64;
		regs->c4_coef = 0x1f68;
		regs->c5_coef = 0x1ed6;
		regs->c6_coef = 0x1c2;
		regs->c7_coef = 0x1c2;
		regs->c8_coef = 0x1e78;
		regs->c9_coef = 0x1fb7;
		regs->coef_i = 0x20;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_HDTV_16_235:
		regs->c1_coef = 0xda;
		regs->c2_coef = 0x2dc;
		regs->c3_coef = 0x4a;
		regs->c4_coef = 0x1f88;
		regs->c5_coef = 0x1e6d;
		regs->c6_coef = 0x20b;
		regs->c7_coef = 0x20b;
		regs->c8_coef = 0x1e25;
		regs->c9_coef = 0x1fd0;
		regs->coef_i = 1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_HDTV_0_255:
		regs->c1_coef = 0xbb;
		regs->c2_coef = 0x275;
		regs->c3_coef = 0x3f;
		regs->c4_coef = 0x1f99;
		regs->c5_coef = 0x1ea6;
		regs->c6_coef = 0x1c2;
		regs->c7_coef = 0x1c2;
		regs->c8_coef = 0x1e67;
		regs->c9_coef = 0x1fd7;
		regs->coef_i = 0x21;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_JFIF_0_255:
		regs->c1_coef = 0x132;
		regs->c2_coef = 0x259;
		regs->c3_coef = 0x75;
		regs->c4_coef = 0x1f53;
		regs->c5_coef = 0x1ead;
		regs->c6_coef = 0x200;
		regs->c7_coef = 0x200;
		regs->c8_coef = 0x1e53;
		regs->c9_coef = 0x1fad;
		regs->coef_i = 0x1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_SMPTE_170M:
		regs->c1_coef = 0x132;
		regs->c2_coef = 0x259;
		regs->c3_coef = 0x75;
		regs->c4_coef = 0x1f50;
		regs->c5_coef = 0x1ea5;
		regs->c6_coef = 0x20b;
		regs->c7_coef = 0x20b;
		regs->c8_coef = 0x1e4a;
		regs->c9_coef = 0x1fab;
		regs->coef_i = 1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_YC_SMPTE_240M:
		regs->c1_coef = 0xd9;
		regs->c2_coef = 0x2ce;
		regs->c3_coef = 0x59;
		regs->c4_coef = 0x2f89;
		regs->c5_coef = 0x1e77;
		regs->c6_coef = 0x200;
		regs->c7_coef = 0x200;
		regs->c8_coef = 0x1e38;
		regs->c9_coef = 0x1fc8;
		regs->coef_i = 1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_RGB_BYPASS:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0;
		regs->c6_coef = 0;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 0x101;
		regs->coef_k = 0x101;
		break;
	case AMX_CSC_YC_RGB_SDTV_16_235:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0x57c;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0x1ea8;
		regs->c6_coef = 0x1d35;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0x6ee;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_SDTV_0_255:
		regs->c1_coef = 0x4a8;
		regs->c2_coef = 0;
		regs->c3_coef = 0x662;
		regs->c4_coef = 0x4a8;
		regs->c5_coef = 0x1e70;
		regs->c6_coef = 0x1cbf;
		regs->c7_coef = 0x4a8;
		regs->c8_coef = 0x812;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_HDTV_16_235:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0x629;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0x1f45;
		regs->c6_coef = 0x1e2a;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0x744;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_HDTV_0_255:
		regs->c1_coef = 0x4a8;
		regs->c2_coef = 0;
		regs->c3_coef = 0x72c;
		regs->c4_coef = 0x4a8;
		regs->c5_coef = 0x1f26;
		regs->c6_coef = 0x1ddd;
		regs->c7_coef = 0x4a8;
		regs->c8_coef = 0x876;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_JFIF_0_255:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0x59c;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0x1ea0;
		regs->c6_coef = 0x1d25;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0x717;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_SMPTE_170M:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0x57c;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0x1ea8;
		regs->c6_coef = 0x1d35;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0x6ee;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_RGB_SMPTE_240M:
		regs->c1_coef = 0x400;
		regs->c2_coef = 0;
		regs->c3_coef = 0x64d;
		regs->c4_coef = 0x400;
		regs->c5_coef = 0x1f19;
		regs->c6_coef = 0x1e00;
		regs->c7_coef = 0x400;
		regs->c8_coef = 0x74f;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	case AMX_CSC_YC_BYPASS:
		regs->c1_coef = 400;
		regs->c2_coef = 0;
		regs->c3_coef = 0;
		regs->c4_coef = 400;
		regs->c5_coef = 0;
		regs->c6_coef = 0;
		regs->c7_coef = 400;
		regs->c8_coef = 0;
		regs->c9_coef = 0;
		regs->coef_i = 1;
		regs->coef_j = 1;
		regs->coef_k = 1;
		break;
	}

	return 0;
}

INLINE int amx_set_csc_3445(ge_info_t *geinfo, int cscid)
{
	volatile struct ge_regs_3445 *regs;

	regs = (struct ge_regs_3445 *)geinfo->mmio;

	switch (cscid) {
	case AMX_CSC_DEFAULT:
		/* do nothing */
		break;
	case AMX_CSC_RGB_YC_SDTV_16_235:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_SDTV_0_255:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_HDTV_16_235:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_HDTV_0_255:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_JFIF_0_255:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_SMPTE_170M:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_YC_SMPTE_240M:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_RGB_BYPASS:
		regs->ge_amx_csc_mode = 0;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_RGB_SDTV_16_235:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_RGB_SDTV_0_255:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 1;
		break;
	case AMX_CSC_YC_RGB_HDTV_16_235:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_RGB_HDTV_0_255:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 1;
		break;
	case AMX_CSC_YC_RGB_JFIF_0_255:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_RGB_SMPTE_170M:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_RGB_SMPTE_240M:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	case AMX_CSC_YC_BYPASS:
		regs->ge_amx_csc_mode = 1;
		regs->ge_amx_y_sub_16_en = 0;
		break;
	}

	regs->g1_yuv_outp_sel = 0; /* progressive */
	regs->g2_yuv_outp_sel = 0; /* progressive */

	return 0;
}

INLINE int amx_set_csc(ge_info_t *geinfo, int cscid)
{
	unsigned int major = geinfo->id >> 16;

	amx_set_csc_basic(geinfo, cscid);

	if (major == 0x3445) /* WM3445 B0 */
		amx_set_csc_3445(geinfo, cscid);

	return 0;
}


/* import ./lib/ge_regs_ext.c */

/* #include "ge_regs.h" */
/* #include "ge_regs_ext.h" */

#define IGNORE(x) (void)(x)

int ge_reset(ge_info_t *geinfo)
{
	volatile ge_regs_t *regs;
	unsigned int val;

	regs = (ge_regs_t *)geinfo->mmio;

	regs->bitblt_alpha = 0xff;
	regs->ck_sel = 0;
	val = regs->ge_eng_en;
	regs->ge_eng_en = 0;
	ge_mb();
	regs->ge_eng_en = val;

	return 0;
}

int ge_set_region(ge_info_t *geinfo, ge_surface_t *s,
	int x, int y, int w, int h)
{
	unsigned int ux;
	unsigned int uy;
	unsigned int uw;
	unsigned int uh;

	IGNORE(geinfo);

	ux = x > 0 ? x : 0;
	uy = y > 0 ? y : 0;
	uw = w > 0 ? w : 0;
	uh = h > 0 ? h : 0;

	if ((ux + uw) > s->xres_virtual)
		uw = s->xres_virtual - ux;

	if ((uy + uh) > s->yres_virtual)
		uh = s->yres_virtual - uy;

	s->x = ux;
	s->y = uy;
	s->xres = uw;
	s->yres = uh;

	return 0;
}

int ge_clear(ge_info_t *geinfo, ge_surface_t *s, int r, int g, int b, int a)
{
	volatile ge_regs_t *regs;
	unsigned int tmp;

	regs = (ge_regs_t *)geinfo->mmio;
	ge_lock(geinfo);
	tmp = regs->alpha_sel;
	regs->alpha_sel = 2; /* alpha is from pattern */
	regs->alpha_plane_wbe = 1;
	ge_set_destination(geinfo, s);
	ge_set_color(geinfo, r, g, b, a, s->pixelformat);
	ge_cmd_fillrect(geinfo);
	ge_wait_sync(geinfo);
	regs->alpha_sel = tmp;
	ge_unlock(geinfo);

	return 0;
}

void ge_rop3(ge_info_t *geinfo, const ge_surface_t *s, const ge_surface_t *d,
	int r, int g, int b, int a, int rop)
{
	volatile ge_regs_t *regs;
	unsigned int alpha_sel;

	regs = (ge_regs_t *)geinfo->mmio;
	ge_lock(geinfo);
	alpha_sel = regs->alpha_sel;
	regs->alpha_sel = 2; /* alpha is from pattern */
	if (s)
		ge_set_source(geinfo, (ge_surface_t *)s);
	if (d)
		ge_set_destination(geinfo, (ge_surface_t *)d);
	ge_set_color(geinfo, r, g, b, a, d->pixelformat);
	ge_set_command(geinfo, GECMD_BLIT, rop & 0xff);
	ge_wait_sync(geinfo);
	regs->alpha_sel = alpha_sel;
	ge_unlock(geinfo);
}

int ge_draw_colorbar(ge_info_t *geinfo, const ge_surface_t *src)
{
	int x;
	int y;
	int w;
	int h;
	ge_surface_t s[1];

	memcpy(s, src, sizeof(ge_surface_t));

	x = s->x;
	y = s->y;

	/* ge_clear background */
	ge_clear(geinfo, s, 0xff, 0xff, 0xff, 0xff);

	/* draw color bar */
	w = s->xres >> 2;
	h = s->yres;

	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0xff, 0xff, 0, 0xff);

	x += w;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0xff, 0, 0, 0xff);

	x += w;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0, 0xff, 0, 0xff);

	x += w;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0, 0, 0xff, 0xff);

	return 0;
}

int ge_draw_colorbar_h(ge_info_t *geinfo, const ge_surface_t *src)
{
	int x;
	int y;
	int w;
	int h;
	ge_surface_t s[1];

	memcpy(s, src, sizeof(ge_surface_t));

	x = s->x;
	y = s->y;

	/* ge_clear background */
	ge_clear(geinfo, s, 0xff, 0xff, 0xff, 0xff);

	/* draw color bar */
	w = s->xres;
	h = s->yres >> 2;

	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0xff, 0xff, 0, 0xff);

	y += h;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0xff, 0, 0, 0xff);

	y += h;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0, 0xff, 0, 0xff);

	y += h;
	ge_set_region(geinfo, s, x, y, w, h);
	ge_clear(geinfo, s, 0, 0, 0xff, 0xff);

	return 0;
}

int ge_blend_enable(ge_info_t *geinfo, int enable)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;
	regs->adap_blend_en = enable & 0x1;

	return 0;
}

int ge_set_src_blend(ge_info_t *geinfo, int blendfunc)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;
	regs->adap_clamp_en = 1;

	switch (blendfunc) {
	case GSBF_ZERO:		/* cf:    0           af:    0 */
		regs->src_alpha_sel = 4;
		regs->src_blend_apa = 0;
		break;
	case GSBF_ONE:		/* cf:    1           af:    1 */
		regs->src_alpha_sel = 4;
		regs->src_blend_apa = 0xff;
		break;
	case GSBF_SRCALPHA:	/* cf:   sa           af:   sa */
		regs->src_alpha_sel = 0;
		break;
	case GSBF_INVSRCALPHA:	/* cf: 1-sa           af: 1-sa */
		regs->src_alpha_sel = 1;
		break;
	case GSBF_DESTALPHA:	/* cf:   da           af:   da */
		regs->src_alpha_sel = 2;
		break;
	case GSBF_INVDESTALPHA:	/* cf: 1-da           af: 1-da */
		regs->src_alpha_sel = 3;
		break;
	case GSBF_UNKNOWN:
	default:
		regs->adap_blend_en = 0;
		return -1;
	}

	return 0;
}

int ge_set_dst_blend(ge_info_t *geinfo, int blendfunc)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;
	regs->adap_clamp_en = 1;

	switch (blendfunc) {
	case GSBF_ZERO:		/* cf:    0           af:    0 */
		regs->des_alpha_sel = 4;
		regs->des_blend_apa = 0;
		break;
	case GSBF_ONE:		/* cf:    1           af:    1 */
		regs->des_alpha_sel = 4;
		regs->des_blend_apa = 0xff;
		break;
	case GSBF_SRCALPHA:	/* cf:   sa           af:   sa */
		regs->des_alpha_sel = 0;
		break;
	case GSBF_INVSRCALPHA:	/* cf: 1-sa           af: 1-sa */
		regs->des_alpha_sel = 1;
		break;
	case GSBF_DESTALPHA:	/* cf:   da           af:   da */
		regs->des_alpha_sel = 2;
		break;
	case GSBF_INVDESTALPHA:	/* cf: 1-da           af: 1-da */
		regs->des_alpha_sel = 3;
		break;
	case GSBF_UNKNOWN:
	default:
		regs->adap_blend_en = 0;
		return -1;
	}

	return 0;
}

void ge_set_govr_fixed_alpha(ge_info_t *geinfo, int src_hit, int des_hit,
	int src_alpha, int des_alpha)
{
	volatile ge_regs_t *regs;
	int sel;

	/* Use GOVR_SRC_BLEND_DATA for D_DATA when D does not hit. */
	/* Use GOVR_DES_BLEND_DATA for S_DATA when S does not hit. */

	IGNORE(src_alpha);
	IGNORE(des_alpha);

	regs = (ge_regs_t *)geinfo->mmio;
	sel = (src_hit << 1) & des_hit;

	switch (sel) {
	case 0:
		/* src_hit = 0, des_hit = 0 */
		regs->govr_no_hit_data = 0;
		break;
	case 1:
		/* src_hit = 0, des_hit = 1 */
		regs->src_govr_hit_01_sel = 0;
		regs->des_govr_hit_01_sel = 0;
		regs->src_fix_01_apa = 0;
		regs->des_fix_01_apa = 0x100;
		regs->govr_des_blend_data = 0;
		break;
	case 2:
		/* src_hit = 1, des_hit = 0 */
		regs->src_govr_hit_10_sel = 0;
		regs->des_govr_hit_10_sel = 0;
		regs->src_fix_10_apa = 0x100;
		regs->des_fix_10_apa = 0;
		regs->govr_src_blend_data = 0;
		break;
	case 3:
		/* src_hit = 1, des_hit = 1 */
		regs->src_govr_hit_11_sel = 0;
		regs->des_govr_hit_11_sel = 0;
		regs->src_fix_11_apa = 0x100;
		regs->des_fix_11_apa = 0;
		break;
	default:
		break;
	}
}

static int set_pat_color(ge_info_t *geinfo, unsigned int *buf, int num)
{
	volatile ge_regs_t *regs;
	volatile unsigned int *p;
	int i;

	if (num > 16)
		return -EINVAL;

	regs = (ge_regs_t *)geinfo->mmio;
	p = &regs->pat0_color;

	for (i = 0; i < num; i++)
		*p++ = buf[i];

	return 0;
}

int ge_write_buf(ge_info_t *geinfo, unsigned int pa, unsigned int *buf,
	unsigned int len)
{
	volatile ge_regs_t *regs;
	ge_surface_t s;
	unsigned int *p;
	unsigned int reg_alpha_sel;

	if (len & 0x3f) /* 2x8x4 = 64 byte alignment */
		return -EINVAL;

	s.addr = pa;
	s.xres = 8;
	s.yres = 2;
	s.xres_virtual = 8;
	s.yres_virtual = 8;
	s.x = 0;
	s.y = 0;
	s.pixelformat = GSPF_RGB32;

	regs = (ge_regs_t *)geinfo->mmio;
	reg_alpha_sel = regs->alpha_sel;
	regs->pat0_buf = 0x76543210;
	regs->pat1_buf = 0xfedcba98;
	regs->alpha_sel = 2; /* alpha is from pattern */
	regs->alpha_plane_wbe = 1;

	ge_lock(geinfo);
	p = buf;

	while (len) {
		ge_set_destination(geinfo, &s);
		set_pat_color(geinfo, p, 16);
		ge_cmd_fillrect(geinfo);
		ge_wait_sync(geinfo);
		p += 16;
		len -= 64; /* 2x8x4 = 64 bytes */
		s.y += s.yres;
		if (s.y >= s.yres_virtual) {
			s.addr += 256; /* 8x8x4 = 256 bytes */
			s.y = 0;
		}
	}
	regs->alpha_sel = reg_alpha_sel;
	regs->pat0_buf = 0;
	regs->pat1_buf = 0;
	ge_unlock(geinfo);

	return 0;
}

void amx_wait_vsync(ge_info_t *geinfo)
{
	volatile ge_regs_t *regs;

	regs = (ge_regs_t *)geinfo->mmio;
	regs->ge_vsync_sts = 0x1;

	while (!regs->ge_vsync_sts);
}


/* import ./lib/ge_helper.c */

#define __GE_HELPER_DEBUG__

#ifdef __GE_HELPER_DEBUG__
/* #include <ge_log.h> */
#endif /* __GE_HELPER_DEBUG__ */

/* #include <ge_helper.h> */

#ifdef __POST__
/* fix compiler warnings in com-vpp.h */
#ifndef U32
#define U32 unsigned int
#endif
#ifndef U16
#define U16 unsigned short
#endif
#ifndef U8
#define U8 unsigned char
#endif
#endif /* __POST__ */

#ifdef __KERNEL__
#define ENABLE_GE_HELPER
#endif /* __KERNEL__ */

#ifndef ENABLE_GE_HELPER
#define DISABLE_GE_HELPER
#endif

#ifndef DISABLE_GE_HELPER
#ifdef __KERNEL__
#include <mach/com-video.h>
#include "../com-vpp.h"
#else
#include <com-video.h>
#include <com-vpp.h>
#endif
#endif

#ifdef __POST__
#ifndef VDO_FLAG_MB_NO
#define VDO_FLAG_MB_NO BIT3
#endif
#endif

#define IGNORE(x) (void)(x)

/* optional helper functions */

extern int ge_verify_surface(ge_info_t *geinfo, ge_surface_t *s);

void ge_helper_print_vdo_framebuf(void *vfb)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(vfb);
#else /* DISABLE_GE_HELPER */
	vdo_framebuf_t *p = (vdo_framebuf_t *) vfb;
	unsigned long y = p->y_addr;
	unsigned long c = p->c_addr;

	ge_log(	GE_LOG_INFO,
		"vdo_framebuf_t:\n"
		"y_addr = %p, y_size = %d\n"
		"c_addr = %p, c_size = %d\n"
		"img_w = %d, img_h = %d\n"
		"fb_w = %d, fb_w = %d\n"
		"h_crop = %d, v_crop = %d\n"
		"bpp = %d, flag = %d\n"
		"col_fmt = %d",
		(void *) y, p->y_size,
		(void *) c, p->c_size,
		p->img_w, p->img_h,
		p->fb_w, p->fb_h,
		p->h_crop, p->v_crop,
		p->bpp, p->flag,
		p->col_fmt
		);
#endif /* DISABLE_GE_HELPER */
}

void ge_helper_print_vdo_view(void *view)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(view);
#else /* DISABLE_GE_HELPER */
	vdo_view_t *p = (vdo_view_t *) view;

	ge_log( GE_LOG_INFO,
		"vdo_view_t:\n"
		"resx_src = %d\n"
		"resy_src = %d\n"
		"resx_virtual = %d\n"
		"resy_virtual = %d\n"
		"offsetx = %d\n"
		"offsety = %d\n"
		"resx_visual = %d\n"
		"resy_visual = %d\n"
		"posx = %d\n"
		"posy = %d\n",
		p->resx_src,
		p->resy_src,
		p->resx_virtual,
		p->resy_virtual,
		p->offsetx,
		p->offsety,
		p->resx_visual,
		p->resy_visual,
		p->posx,
		p->posy);
#endif /* DISABLE_GE_HELPER */
}

void *ge_helper_create_vdo_view(void)
{
#ifdef DISABLE_GE_HELPER
	return NULL;
#else  /* DISABLE_GE_HELPER */
#ifdef __KERNEL__
	return kcalloc(1, sizeof(vdo_view_t), GFP_KERNEL);
#else  /* __KERNEL__ */
	return calloc(1, sizeof(vdo_view_t));
#endif /* __KERNEL__ */
#endif /* DISABLE_GE_HELPER */
}

void ge_helper_release_vdo_view(void *vdo_view)
{
	if (vdo_view)
#ifdef __KERNEL__
		kfree(vdo_view);
#else
		free(vdo_view);
#endif
}

void ge_helper_get_vdo_view(void *vdo_view,
			    const ge_surface_t *src,
			    const ge_rect_t *sr,
			    const ge_rect_t *dr)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(vdo_view);
	IGNORE(src);
	IGNORE(sr);
	IGNORE(dr);
#else /* DISABLE_GE_HELPER */
	vdo_view_t *view;

	view = (vdo_view_t *) vdo_view;

	view->resx_src     = src->xres_virtual;
	view->resy_src     = src->yres_virtual;

	if (sr) {
		view->resx_virtual = sr->w;
		view->resy_virtual = sr->h;
		view->offsetx      = sr->x;
		view->offsety      = sr->y;
	} else {
		view->resx_virtual = src->xres;
		view->resy_virtual = src->yres;
		view->offsetx      = src->x;
		view->offsety      = src->y;
	}

	if (dr) {
		view->resx_visual  = dr->w;
		view->resy_visual  = dr->h;
		view->posx         = dr->x;
		view->posy         = dr->y;
	} else {
		view->resx_visual  = sr ? sr->w : src->xres;
		view->resy_visual  = sr ? sr->h : src->yres;
		view->posx         = 0;
		view->posy         = 0;
	}

	/* pixelformat was not used */
#endif /* DISABLE_GE_HELPER */
}

void ge_helper_set_vdo_view(const void *vdo_view,
			    ge_surface_t *src,
			    ge_rect_t *sr,
			    ge_rect_t *dr)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(vdo_view);
	IGNORE(src);
	IGNORE(sr);
	IGNORE(dr);
#else /* DISABLE_GE_HELPER */
	vdo_view_t *view;

	view = (vdo_view_t *) vdo_view;

	if (src) {
		src->xres_virtual = view->resx_src;
		src->yres_virtual = view->resy_src;
		src->xres         = view->resx_virtual;
		src->yres         = view->resy_virtual;
		src->x            = view->offsetx;
		src->y            = view->offsety;
	}

	if (sr) {
		sr->x = view->offsetx;
		sr->y = view->offsety;
		sr->w = view->resx_virtual;
		sr->h = view->resy_virtual;
	}

	if (dr) {
		dr->w = view->resx_visual;
		dr->h = view->resy_visual;
		dr->x = view->posx;
		dr->y = view->posy;
	}

	/* pixelformat was not used */
#endif /* DISABLE_GE_HELPER */
}

void *ge_helper_create_vdo_framebuf(void)
{
#ifdef DISABLE_GE_HELPER
	return NULL;
#else  /* DISABLE_GE_HELPER */
#ifdef __KERNEL__
	return kcalloc(1, sizeof(vdo_framebuf_t), GFP_KERNEL);
#else  /* __KERNEL__ */
	return calloc(1, sizeof(vdo_framebuf_t));
#endif /* __KERNEL__ */
#endif /* DISABLE_GE_HELPER */
}

void ge_helper_release_vdo_framebuf(void *vdo_framebuf)
{
	if (vdo_framebuf)
#ifdef __KERNEL__
		kfree(vdo_framebuf);
#else
		free(vdo_framebuf);
#endif
}

void ge_helper_get_vdo_framebuf(void *vdo_framebuf,
				const ge_surface_t *src,
				const ge_rect_t *sr)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(vdo_framebuf);
	IGNORE(src);
	IGNORE(sr);
#else /* DISABLE_GE_HELPER */
	vdo_framebuf_t *vfb;

	vfb = (vdo_framebuf_t *) vdo_framebuf;

	vfb->img_w  = sr ? sr->w : src->xres;
	vfb->img_h  = sr ? sr->h : src->yres;
	vfb->fb_w   = src->xres_virtual;
	vfb->fb_h   = src->yres_virtual;
	vfb->h_crop = sr ? sr->x : src->x;
	vfb->v_crop = sr ? sr->y : src->y;
	vfb->flag   = 0;

	if (src->caps & GSCAPS_MB)
		vfb->flag |= VDO_FLAG_MB_ONE;
	else
		vfb->flag |= VDO_FLAG_MB_NO;

	if (src->caps & GSCAPS_INTERLACE)
		vfb->flag |= VDO_FLAG_INTERLACE;

	if (src->caps & GSCAPS_MOTION_VECTOR)
		vfb->flag |= VDO_FLAG_MOTION_VECTOR;

	vfb->y_addr = src->addr;
	vfb->c_addr = src->addr + src->planesize[0];
	vfb->y_size = src->planesize[0];
	vfb->c_size = src->planesize[1];

	switch (src->pixelformat) {
	case GSPF_YUV420SP:
		vfb->bpp = 0;
		vfb->col_fmt = VDO_COL_FMT_YUV420;
		break;
	case GSPF_YUV422SP:
		vfb->bpp = 0;
		vfb->col_fmt = VDO_COL_FMT_YUV422H;
		break;
	case GSPF_YUV444SP:
		vfb->bpp = 0;
		vfb->col_fmt = VDO_COL_FMT_YUV444;
		break;
	case GSPF_YUV411SP:
		vfb->bpp = 0;
		vfb->col_fmt = VDO_COL_FMT_YUV411;
		break;
	case GSPF_LUT8:
		vfb->bpp = 8;
		vfb->col_fmt = VDO_COL_FMT_GRAY;
		break;
	case GSPF_RGB32:
	case GSPF_ARGB:
		vfb->bpp = 32;
		vfb->col_fmt = VDO_COL_FMT_ARGB;
		break;
	case GSPF_RGB24:
		vfb->bpp = 24;
		vfb->col_fmt = VDO_COL_FMT_RGB_888;
		break;
	case GSPF_RGB16:
		vfb->bpp = 16;
		vfb->col_fmt = VDO_COL_FMT_RGB_565;
		break;
	case GSPF_RGB555:
		vfb->bpp = 16;
		vfb->col_fmt = VDO_COL_FMT_RGB_1555;
		break;
	default:
		vfb->bpp = 0;
		vfb->col_fmt = VDO_COL_FMT_UNKNOWN;
	}
#endif /* DISABLE_GE_HELPER */
}

void ge_helper_set_vdo_framebuf(const void *vdo_framebuf,
				ge_surface_t *src,
				ge_rect_t *sr)
{
#ifdef DISABLE_GE_HELPER
	IGNORE(vdo_framebuf);
	IGNORE(src);
	IGNORE(sr);
#else /* DISABLE_GE_HELPER */
	vdo_framebuf_t *vfb;

	vfb = (vdo_framebuf_t *) vdo_framebuf;

	src->addr = vfb->y_addr;
	src->xres = vfb->img_w;
	src->yres = vfb->img_h;
	src->xres_virtual = vfb->fb_w;
	src->yres_virtual = vfb->fb_h;
	src->x = vfb->h_crop;
	src->y = vfb->v_crop;

	if (sr) {
		sr->x = src->x;
		sr->y = src->y;
		sr->w = src->xres;
		sr->h = src->yres;
	}

	switch (vfb->col_fmt) {
	case VDO_COL_FMT_YUV420:
		src->pixelformat = GSPF_YUV420SP;
		break;
	case VDO_COL_FMT_YUV422H:
		src->pixelformat = GSPF_YUV422SP;
		break;
	case VDO_COL_FMT_YUV444:
		src->pixelformat = GSPF_YUV444SP;
		break;
	case VDO_COL_FMT_YUV411:
		src->pixelformat = GSPF_YUV411SP;
		break;
	case VDO_COL_FMT_GRAY:
		src->pixelformat = GSPF_LUT8;
		break;
	case VDO_COL_FMT_ARGB:
		src->pixelformat = GSPF_ARGB;
		break;
	case VDO_COL_FMT_RGB_888:
		src->pixelformat = GSPF_RGB24;
		break;
	case VDO_COL_FMT_RGB_565:
		src->pixelformat = GSPF_RGB16;
		break;
	case VDO_COL_FMT_RGB_1555:
		src->pixelformat = GSPF_RGB555;
		break;
	default:
		src->pixelformat = 0;
	}

	src->caps = GSCAPS_NONE;

	if (vfb->flag & VDO_FLAG_MB_ONE)
		src->caps |= GSCAPS_MB;

	if (vfb->flag & VDO_FLAG_INTERLACE)
		src->caps |= GSCAPS_INTERLACE;

	if (vfb->flag & VDO_FLAG_MOTION_VECTOR)
		src->caps |= GSCAPS_MOTION_VECTOR;

	ge_verify_surface((void *)0, src);
#endif /* DISABLE_GE_HELPER */
}


/* import ./lib/wgl.c */

/* #include <wgl.h> */
#ifdef __LINUX__
#include <sched.h>
#endif
#ifdef __POST__
#ifndef u_int16_t
#define u_int16_t unsigned short
#endif
#ifndef u_int32_t
#define u_int32_t unsigned int
#endif
#endif

#define IGNORE(x) (void)(x)

static void local_print_surface_info(const ge_surface_t *s, const char *name)
{
	ge_log(	GE_LOG_DEBUG,
		"(%s) %08lx: %lu, %lu, %lu, %lu, %lu, %lu, %08lx\n",
		name,
		s->addr, s->x, s->y, s->xres, s->yres,
		s->xres_virtual, s->yres_virtual, s->pixelformat);
}

#if !defined(__POST__) && !defined(__KERNEL__)
static void local_var_to_gs(struct fb_var_screeninfo *var, ge_surface_t *surface)
{
	unsigned long offset;

	surface->xres = var->xres;
	surface->yres = var->yres;
	surface->xres_virtual = var->xres_virtual;
	surface->yres_virtual = var->yres;
	surface->x = 0;
	surface->y = 0;
	surface->pixelformat =
		var->bits_per_pixel == 16 ? GSPF_RGB16 : GSPF_RGB32;
	offset = var->yoffset * var->xres_virtual + var->xoffset;
	offset *= var->bits_per_pixel >> 3;
	surface->addr += offset;
}
#endif /* !defined(__POST__) */

#ifdef __LINUX__
void ge_get_primary_surface(ge_info_t *geinfo, ge_surface_t *surface)
{
	struct fb_var_screeninfo fb_var;
	struct fb_fix_screeninfo fb_fix;

	ioctl(geinfo->fd, FBIOGET_FSCREENINFO, &fb_fix);
	ioctl(geinfo->fd, FBIOGET_VSCREENINFO, &fb_var);
	surface->addr = fb_fix.smem_start;
	local_var_to_gs(&fb_var, surface);

	surface->caps = GSCAPS_FB;
}

ge_surface_t *ge_create_primary_surface(ge_info_t *geinfo)
{
	ge_surface_t *s;

#ifdef __KERNEL__
	s = (ge_surface_t *) kcalloc(1, sizeof(ge_surface_t), GFP_KERNEL);
#else  /* __KERNEL__ */
	s = (ge_surface_t *) calloc(1, sizeof(ge_surface_t));
#endif /* __KERNEL__ */

	if (s)
		ge_get_primary_surface(geinfo, s);

	return s;
}
#endif /* __LINUX__ */

int ge_verify_surface(ge_info_t *geinfo, ge_surface_t *s)
{
	size_t fbw;
	size_t fbh;

	IGNORE(geinfo);

	if (!s)
		return -1;

	fbw = s->xres_virtual;
	fbh = s->yres_virtual;

	switch (s->pixelformat) {
	case GSPF_YUV420P:
		s->planesize[0] = fbw * fbh;
		s->planesize[1] = s->planesize[0] >> 2;
		s->planesize[2] = s->planesize[1];
		break;
	case GSPF_YUV420SP: /* NV12 */
		s->planesize[0] = fbw * fbh;
		s->planesize[1] = s->planesize[0] >> 1;
		break;
	case GSPF_YUV422SP: /* NV16 */
		s->planesize[0] = fbw * fbh;
		s->planesize[1] = s->planesize[0];
		break;
	case GSPF_YUV444SP:
		s->planesize[0] = fbw * fbh;
		s->planesize[1] = s->planesize[0] << 1;
		break;
	default:
		if (GSPF_YUV(s->pixelformat) == 0)
			s->planesize[0] = fbw * fbh *
				GSPF_BYTES_PER_PIXEL(s->pixelformat);
		else
			s->planesize[0] = fbw * fbh;
	}

	return 0;
}

ge_surface_t *ge_create_null_surface(ge_info_t *geinfo,
				     int w,
				     int h,
				     int pixfmt)
{
	ge_surface_t *s;
	size_t fbw;
	size_t fbh;

	if (GSPF_YUV(pixfmt)) {
		if (GSPF_PLANES(pixfmt) == 2)
			fbw = (w + 63) & ~63; /* YC */
		else
			fbw = (w + 15) & ~15; /* YUV */
		fbh = (h + 15) & ~15;
	} else {
		fbw = w;
		fbh = h;
	}

#ifdef __KERNEL__
	s = (ge_surface_t *) kcalloc(1, sizeof(ge_surface_t), GFP_KERNEL);
#else  /* __KERNEL__ */
	s = (ge_surface_t *) calloc(1, sizeof(ge_surface_t));
#endif /* __KERNEL__ */
	if (s) {
		s->addr = 0;
		s->xres = w;
		s->yres = h;
		s->xres_virtual = fbw;
		s->yres_virtual = fbh;
		s->x = 0;
		s->y = 0;
		s->pixelformat = pixfmt;
	}

	ge_verify_surface(geinfo, s);

	return s;
}

ge_surface_t *ge_dup_surface(ge_info_t *geinfo, const ge_surface_t *s)
{
	ge_surface_t *dup;

	dup = ge_create_null_surface(geinfo, s->xres_virtual, s->yres_virtual,
					s->pixelformat);
	memcpy(dup, s, sizeof(ge_surface_t));
	dup->caps |= GSCAPS_STATIC;

	return dup;
}

ge_surface_t *ge_create_surface(ge_info_t *geinfo, int w, int h, int pixfmt)
{
	struct gmp *gmp;
	unsigned long pa;
	ge_surface_t *s;
	size_t size;
	size_t fbw;
	size_t fbh;

	gmp = geinfo->gmp;

	/* TODO: handle YUV surface here */
	if (GSPF_YUV(pixfmt)) {
		if (GSPF_PLANES(pixfmt) == 2)
			fbw = (w + 63) & ~63; /* YC */
		else
			fbw = (w + 15) & ~15; /* YUV */
		fbh = (h + 15) & ~15;
	} else {
		fbw = w;
		fbh = h;
	}
	size = (fbw * fbh * GSPF_BITS_PER_PIXEL(pixfmt)) >> 3;

	if (!gmp)
		return NULL;

	pa = gmp_alloc(gmp, size, 0);
	if (pa) {
#ifdef __KERNEL__
		s = (ge_surface_t *) kcalloc(1, sizeof(ge_surface_t), GFP_KERNEL);
#else  /* __KERNEL__ */
		s = (ge_surface_t *) calloc(1, sizeof(ge_surface_t));
#endif /* __KERNEL__ */
		if (s) {
			s->addr = pa;
			s->xres = w;
			s->yres = h;
			s->xres_virtual = fbw;
			s->yres_virtual = fbh;
			s->x = 0;
			s->y = 0;
			s->pixelformat = pixfmt;
			s->caps = GSCAPS_GMP;
			switch (pixfmt) {
			case GSPF_YUV420P:
				s->planesize[0] = fbw * fbh;
				s->planesize[1] = s->planesize[0] >> 2;
				s->planesize[2] = s->planesize[1];
				break;
			case GSPF_YUV420SP: /* NV12 */
				s->planesize[0] = fbw * fbh;
				s->planesize[1] = s->planesize[0] >> 1;
				break;
			case GSPF_YUV422SP: /* NV16 */
				s->planesize[0] = fbw * fbh;
				s->planesize[1] = s->planesize[0];
				break;
			case GSPF_YUV444SP:
				s->planesize[0] = fbw * fbh;
				s->planesize[1] = s->planesize[0] << 1;
				break;
			default:
				s->planesize[0] = size;
			}
		}
	} else
		s = NULL;

	return s;
}

void ge_release_surface(ge_info_t *geinfo, ge_surface_t *surface)
{
	struct gmp *gmp;

	gmp = geinfo->gmp;

	if ((surface->caps & GSCAPS_STATIC) == 0) {
		if (gmp && surface->caps & GSCAPS_GMP)
			gmp_free(gmp, surface->addr);
	}

#ifdef __KERNEL__
	kfree(surface);
#else  /* __KERNEL__ */
	free(surface);
#endif /* __KERNEL__ */
}

static void *fb_ioremap(ge_info_t *geinfo, unsigned long physaddr, size_t size)
{
#if defined(__LINUX__)
	struct fb_fix_screeninfo fsinfo;
	int fd;
	off_t off;
	void *va;

	fd = geinfo->fd;

	ioctl(fd, FBIOGET_FSCREENINFO, &fsinfo);

	if (physaddr < fsinfo.smem_start) {
		ge_log(GE_LOG_ERR, "[fb] cannot map %p below %p\n",
			physaddr, fsinfo.smem_start);
		return NULL;
	}

	off = ((physaddr - fsinfo.smem_start) + 0xfff) & ~0xfff;
	va = mmap((void *) 0, size,
		PROT_READ|PROT_WRITE, MAP_SHARED, fd, off);

	if (va == MAP_FAILED) {
		ge_log(GE_LOG_ERR, "[fb] cannot map %p for %d bytes\n",
			physaddr, size);
		return NULL;
	}

	return va;
#elif defined(__KERNEL__)
	return ioremap(physaddr, size);
#elif defined(__POST__)
	return (void *) physaddr;
#else
	return NULL;
#endif
}

void fb_iounmap(ge_info_t *geinfo, void *va, size_t size)
{
	IGNORE(geinfo);

#if defined(__LINUX__)
	if (va)
		munmap(va, size);
#elif defined(__KERNEL__)
	if (va)
		iounmap(va);
#endif
}

void ge_lock_surface(ge_info_t *geinfo, ge_surface_t *surface, void **vaddr)
{
	struct gmp *gmp;
	size_t len;
	void *va;

	gmp = geinfo->gmp;
	len = surface->xres_virtual * surface->yres_virtual *
		GE_BYTES_PER_PIXEL(surface->pixelformat);
	len = (len + 0xfff) & ~0xfff; /* 4KB aligned */

	if (surface->caps & GSCAPS_GMP)
		va = gmp_ioremap(gmp, surface->addr, len);
	else if (surface->caps & GSCAPS_FB)
		va = fb_ioremap(geinfo, surface->addr, len);
	else
		va = NULL;

	surface->mmio = (unsigned long) va;
	*vaddr = va;
}

void ge_unlock_surface(ge_info_t *geinfo, ge_surface_t *surface)
{
	struct gmp *gmp;
	size_t len;

	gmp = geinfo->gmp;
	len = surface->xres_virtual * surface->yres_virtual *
		GE_BYTES_PER_PIXEL(surface->pixelformat);
	len = (len + 0xfff) & ~0xfff; /* 4KB aligned */

	if (surface->caps & GSCAPS_GMP) {
		gmp_iounmap(gmp, (void *) surface->mmio, len);
		gmp_cache_flush(gmp, surface->addr, len);
	} else if (surface->caps & GSCAPS_FB) {
		fb_iounmap(geinfo, (void *) surface->mmio, len);
	}

	surface->mmio = 0;
}

static void local_rgb565_to_rgb32(u_int16_t *s, u_int32_t *d)
{
	u_int16_t c;
	u_int32_t r;
	u_int32_t g;
	u_int32_t b;

	c = *s;
	r = (c & 0xf800) << 8;	/* 0xf800 -> 0xf80000 */
	g = (c & 0x7e0) << 5;	/* 0x7e0 -> 0xfc00 */
	b = (c & 0x1f) << 3;	/* 0x1f -> 0xf8 */

	*d = 0xff000000 | r | g | b;
}

static void local_rgb32_to_rgb565(u_int32_t *s, u_int16_t *d)
{
	u_int32_t c;
	u_int32_t r;
	u_int32_t g;
	u_int32_t b;

	c = *s;
	r = (c & 0xf80000) >> 8;/* 0xf80000 -> 0xf800 */
	g = (c & 0xfc00) >> 5;	/* 0xfc00 -> 0x7e0 */
	b = (c & 0xf8) >> 3;	/* 0xf8 -> 0x1f */

	*d =  (r | g | b) & 0xffff;
}

int ge_blit_soft(ge_info_t *geinfo,
		 const ge_surface_t *src,
		 const ge_surface_t *dst,
		 int x,
		 int y)
{
	ge_surface_t s[1];
	ge_surface_t d[1];
	void *pbuf;
	unsigned long pbuf_s;
	unsigned long pbuf_d;
	unsigned long ptr_s;
	unsigned long ptr_d;
	unsigned long posx;
	unsigned long posy;
	size_t len;
	int ret;

	pbuf = NULL;
	ret = 0;
	posx = (unsigned long) x;
	posy = (unsigned long) y;

	memcpy(s, src, sizeof(ge_surface_t));
	memcpy(d, dst, sizeof(ge_surface_t));

	if (s->pixelformat == GSPF_ARGB)
		s->pixelformat = GSPF_RGB32;

	if (d->pixelformat == GSPF_ARGB)
		d->pixelformat = GSPF_RGB32;

	d->xres = s->xres;
	d->yres = s->yres;
	d->x += posx;
	d->y += posy;

	ge_lock_surface(geinfo, s, (void **) &pbuf_s);
	ge_lock_surface(geinfo, d, (void **) &pbuf_d);

	if (s->addr == d->addr) {
		len = (s->xres_virtual * s->yres) *
		      GE_BYTES_PER_PIXEL(s->pixelformat);
#ifdef __KERNEL__
		pbuf = kmalloc(len, GFP_KERNEL);
#else  /* __KERNEL__ */
		pbuf = malloc(len);
#endif /* __KERNEL__ */
		memcpy(pbuf, (void *)pbuf_s, len);
		pbuf_s = (unsigned long)pbuf;
	}

	if (s->pixelformat == GSPF_RGB16 &&
	    d->pixelformat == GSPF_RGB32) {
		pbuf_s += ((s->y * s->xres_virtual + s->x) << 1);
		pbuf_d += ((d->y * d->xres_virtual + d->x) << 2);
		for (posy = s->y; posy < s->yres; posy++) {
			ptr_s = pbuf_s + ((posy * s->xres_virtual) << 1);
			ptr_d = pbuf_d + ((posy * d->xres_virtual) << 2);
			for (posx = 0; posx < s->xres; posx++) {
				local_rgb565_to_rgb32((u_int16_t *)ptr_s,
						(u_int32_t *)ptr_d);
				ptr_s += 2;
				ptr_d += 4;
			}
		}
	} else if (s->pixelformat == GSPF_RGB32 &&
		   d->pixelformat == GSPF_RGB16) {
		pbuf_s += ((s->y * s->xres_virtual + s->x) << 2);
		pbuf_d += ((d->y * d->xres_virtual + d->x) << 1);
		for (posy = s->y; posy < s->yres; posy++) {
			ptr_s = pbuf_s + ((posy * s->xres_virtual) << 2);
			ptr_d = pbuf_d + ((posy * d->xres_virtual) << 1);
			for (posx = 0; posx < s->xres; posx++) {
				local_rgb32_to_rgb565((u_int32_t *) ptr_s,
						(u_int16_t *) ptr_d);
				ptr_s += 4;
				ptr_d += 2;
			}
		}
	} else if (s->pixelformat == GSPF_RGB32 &&
		   d->pixelformat == GSPF_RGB32) {
		ptr_s = pbuf_s + ((s->y * s->xres_virtual + s->x) << 2);
		ptr_d = pbuf_d + ((d->y * d->xres_virtual + d->x) << 2);
		for (posy = s->y; posy < s->yres; posy++) {
			memcpy((void *)ptr_d, (void *)ptr_s,
			       s->xres_virtual << 2);
			ptr_s += s->xres_virtual << 2;
			ptr_d += d->xres_virtual << 2;
		}
	} else if (s->pixelformat == GSPF_RGB16 &&
		   d->pixelformat == GSPF_RGB16) {
		ptr_s = pbuf_s + ((s->y * s->xres_virtual + s->x) << 1);
		ptr_d = pbuf_d + ((d->y * d->xres_virtual + d->x) << 1);
		for (posy = s->y; posy < s->yres; posy++) {
			memcpy((void *)ptr_d, (void *)ptr_s,
			       s->xres_virtual << 1);
			ptr_s += s->xres_virtual << 1;
			ptr_d += d->xres_virtual << 1;
		}
	} else {
		ret = -EINVAL;
	}

	if (pbuf)
#ifdef __KERNEL__
		kfree(pbuf);
#else  /* __KERNEL__ */
		free(pbuf);
#endif /* __KERNEL__ */

	ge_unlock_surface(geinfo, s);
	ge_unlock_surface(geinfo, d);

	return ret;
}

int ge_blit_hard(ge_info_t *geinfo,
		 const ge_surface_t *src,
		 const ge_surface_t *dst,
		 int x,
		 int y)
{
	volatile ge_regs_t *regs;
	unsigned int tmp;
	unsigned int chip_id;
	unsigned int alpha_sel;
	ge_surface_t s[1];
	ge_surface_t d[1];
	int r, g, b, a;
	int rop;

	regs = (ge_regs_t *)geinfo->mmio;

	if (dst->blitting_flags & GSBLIT_BLEND_ALPHACHANNEL) {
		ge_blend_enable(geinfo, 1);
		ge_set_src_blend(geinfo, dst->src_blend_func);
		ge_set_dst_blend(geinfo, dst->dst_blend_func);
	}

	if (dst->blitting_flags & GSBLIT_BLEND_COLORALPHA) {
		regs->bitblt_alpha = dst->color >> 24;
	}

	memcpy(s, src, sizeof(ge_surface_t));
	memcpy(d, dst, sizeof(ge_surface_t));

	ge_get_chip_id(geinfo, &chip_id);
	chip_id >>= 16;

	d->x = x;
	d->y = y;
	d->xres = s->xres;
	d->yres = s->yres;

	tmp = s->xres_virtual | d->xres_virtual;

	if (tmp & 0xf)
		return -EINVAL;

	local_print_surface_info((const ge_surface_t *)s, "src");
	local_print_surface_info((const ge_surface_t *)d, "dst");

	ge_lock(geinfo);
	alpha_sel = regs->alpha_sel;
	if (d->blitting_flags & GSBLIT_ROP) {
		a = d->color >> 24;
		r = d->color >> 16;
		g = d->color >> 8;
		b = d->color & 0xff;
		ge_set_color(geinfo, r, g, b, a, d->pixelformat);
		regs->alpha_sel = 2; /* alpha is from pattern */
		rop = d->rop;
	} else {
		rop = 0xcc;
	}
	regs->alpha_plane_wbe = 1;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	ge_set_command(geinfo, GECMD_BLIT, rop);
	ge_wait_sync(geinfo);
	regs->alpha_sel = alpha_sel;
	regs->bitblt_alpha = 0xff;
	ge_blend_enable(geinfo, 0);
	ge_unlock(geinfo);

	return 0;
}

int ge_blit_scl(ge_info_t *geinfo,
		const ge_surface_t *s,
		const ge_surface_t *d,
		int x,
		int y)
{
	ge_rect_t dr;

	dr.x = x;
	dr.y = y;
	dr.w = s->xres;
	dr.h = s->yres;

	return ge_stretch_blit(geinfo, s, d, NULL, &dr);
}

int ge_blit(ge_info_t *geinfo,
	    const ge_surface_t *s,
	    const ge_surface_t *d,
	    int x,
	    int y)
{
	int err;

	err = ge_blit_hard(geinfo, s, d, x, y);
	if (err)
		err = ge_blit_scl(geinfo, s, d, x, y);
	if (err)
		err = ge_blit_soft(geinfo, s, d, x, y);

	return err;
}

static unsigned int rmif_baddr(const ge_surface_t *s, int type)
{
	unsigned int linesize;
	unsigned int a;
	unsigned int b;

	/* Note: formula was not optimized yet */

	linesize = s->xres_virtual * GSPF_BYTES_PER_PIXEL(s->pixelformat);
	a = linesize * (s->yres - 1);   /* offset to the last line */
	b = ((linesize >> 6) - 1) << 6; /* offset to the last rmif burst (64 byte) */

	if (type == 1) b = 0;
	if (type == 2) a = 0;

	return s->addr + a + b;
}

int ge_rotate(ge_info_t *geinfo,
	      const ge_surface_t *src,
	      const ge_surface_t *dst,
	      int x,
	      int y,
	      int arc)
{
	volatile ge_regs_t *regs;
	unsigned long tmp;
	ge_surface_t s[1];
	ge_surface_t d[1];
	ge_surface_t *ss;
	int s_shift;
	int d_shift;
	int ret;
	int id;

	id = geinfo->id >> 16;

	if (GE_BYTES_PER_PIXEL(src->pixelformat) !=
	    GE_BYTES_PER_PIXEL(dst->pixelformat)) {
		ss = ge_create_surface(geinfo, src->xres, src->yres,
				dst->pixelformat);
		ret = ge_blit(geinfo, src, ss, 0, 0);
		ret = ge_rotate(geinfo, ss, dst, x, y, arc);
		ge_release_surface(geinfo, ss);
		return ret;
	}

	memcpy(s, src, sizeof(ge_surface_t));
	memcpy(d, dst, sizeof(ge_surface_t));

	regs = (ge_regs_t *)geinfo->mmio;

	d->x = x;
	d->y = y;

	if (arc == 90 || arc == 270) {
		d->xres = s->yres;
		d->yres = s->xres;
	} else {
		d->xres = s->xres;
		d->yres = s->yres;
	}

	tmp = s->xres_virtual | d->xres_virtual;

	if (tmp & 0xf)
		return -EINVAL;

	local_print_surface_info((const ge_surface_t *)s, "src");
	local_print_surface_info((const ge_surface_t *)d, "dst");

	if (arc) {
		s_shift = GE_BYTES_PER_PIXEL(s->pixelformat) >> 1;
		d_shift = GE_BYTES_PER_PIXEL(d->pixelformat) >> 1;
		s->addr += ((s->y * s->xres_virtual + s->x) << s_shift);
		d->addr += ((d->y * d->xres_virtual + d->x) << d_shift);
		s->x = s->y = 0;
		d->x = d->y = 0;
		ge_lock(geinfo);
		regs->alpha_plane_wbe = 1;
		ge_set_source(geinfo, s);
		ge_set_destination(geinfo, d);
		if (arc == 180 && id != 0x3445) {
			/* WM3481 */
			regs->src_baddr = rmif_baddr(s, 3);
			regs->des_baddr = rmif_baddr(d, 3);
		}
		ge_cmd_rotate(geinfo, arc);
		ge_wait_sync(geinfo);
		ge_unlock(geinfo);
	} else {
		ge_blit(geinfo, src, dst, x, y);
	}

	return 0;
}

int ge_mirror(ge_info_t *geinfo,
	      const ge_surface_t *src,
	      const ge_surface_t *dst,
	      int x,
	      int y,
	      int mode)
{
	volatile ge_regs_t *regs;
	unsigned long tmp;
	ge_surface_t s[1];
	ge_surface_t d[1];
	ge_surface_t *ss;
	int s_shift;
	int d_shift;
	int ret;
	int id;

	id = geinfo->id >> 16;

	if (GE_BYTES_PER_PIXEL(src->pixelformat) !=
	    GE_BYTES_PER_PIXEL(dst->pixelformat)) {
		ss = ge_create_surface(geinfo, src->xres, src->yres,
				dst->pixelformat);
		ret = ge_blit(geinfo, src, ss, 0, 0);
		ret = ge_mirror(geinfo, ss, dst, x, y, mode);
		ge_release_surface(geinfo, ss);
		return ret;
	}

	memcpy(s, src, sizeof(ge_surface_t));
	memcpy(d, dst, sizeof(ge_surface_t));

	regs = (ge_regs_t *)geinfo->mmio;

	d->x = x;
	d->y = y;
	d->xres = s->xres;
	d->yres = s->yres;

	tmp = s->xres_virtual | d->xres_virtual;

	if (tmp & 0xf)
		return -EINVAL;

	local_print_surface_info((const ge_surface_t *)s, "src");
	local_print_surface_info((const ge_surface_t *)d, "dst");

	s_shift = GE_BYTES_PER_PIXEL(s->pixelformat) >> 1;
	d_shift = GE_BYTES_PER_PIXEL(d->pixelformat) >> 1;
	s->addr += ((s->y * s->xres_virtual + s->x) << s_shift);
	d->addr += ((d->y * d->xres_virtual + d->x) << d_shift);
	s->x = s->y = 0;
	d->x = d->y = 0;
	ge_lock(geinfo);
	regs->alpha_plane_wbe = 1;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	if (id != 0x3445) {
		/* WM3481 */
		if (mode == 0) {
			/* X-mirror */
			regs->src_baddr = rmif_baddr(s, 2);
			regs->des_baddr = rmif_baddr(d, 2);
		} else {
			/* Y-mirror */
			regs->src_baddr = rmif_baddr(s, 1);
			regs->des_baddr = rmif_baddr(d, 1);
		}
	}
	ge_cmd_mirror(geinfo, mode);
	ge_wait_sync(geinfo);
	ge_unlock(geinfo);

	return 0;
}

int ge_stretch_blit(ge_info_t *geinfo,
		    const ge_surface_t *src,
		    const ge_surface_t *dst,
		    const ge_rect_t *src_rect,
		    const ge_rect_t *dst_rect)
{
#ifdef __LINUX__
	struct ge_plugin *plugin;
	ge_surface_t s[1];
	ge_surface_t d[1];
	void *src_fb;
	void *dst_fb;
	unsigned int pixlen;
	int ret;
	int len;
	unsigned long msk;

	memcpy(s, src, sizeof(ge_surface_t));
	memcpy(d, dst, sizeof(ge_surface_t));

	if (src_rect) {
		s->x = src_rect->x;
		s->y = src_rect->y;
		s->xres = src_rect->w;
		s->yres = src_rect->h;
	}

	if (dst_rect) {
		d->x = dst_rect->x;
		d->y = dst_rect->y;
		d->xres = dst_rect->w;
		d->yres = dst_rect->h;
	}

	/* 64-bytes alignment */
	len = s->xres_virtual * GE_BYTES_PER_PIXEL(s->pixelformat);
	if (len & 0x3f)
		return -EINVAL;

	/* 64-bytes alignment */
	len = d->xres_virtual * GE_BYTES_PER_PIXEL(d->pixelformat);
	if (len & 0x3f)
		return -EINVAL;

	/* 4-byte alignment */
	msk = (4 / GE_BYTES_PER_PIXEL(s->pixelformat)) - 1;
	if ((s->x & msk) | ((s->xres & msk)))
		return -EINVAL;

	/* 4-byte alignment */
	msk = (4 / GE_BYTES_PER_PIXEL(d->pixelformat)) - 1;
	if ((d->x & msk) | ((d->xres & msk)))
		return -EINVAL;

	local_print_surface_info((const ge_surface_t *)s, "src");
	local_print_surface_info((const ge_surface_t *)d, "dst");

	/* Instead of checking COLOR_ALPHA and COLORKEY by registers,
	 * we should trust DirectFB's CheckState(), and do the job.
	 * After all, this plugin was dedicated to DirectFB.
	 */
	/* Not support COLOR_ALPHA and COLORKEY */

	pixlen = GE_BYTES_PER_PIXEL(d->pixelformat);

	d->addr += (d->xres_virtual * d->y + d->x) * pixlen;
	d->x = 0;
	d->y = 0;
	d->yres_virtual -= d->y;

	ge_verify_surface(geinfo, d);

	/* Use SCL444 for stretch blit */

	/*
	local_print_surface_info((const ge_surface_t *)d, "dst");
	*/

	if (!geinfo->plugin) {
		geinfo->plugin = create_ge_plugin();
		if (!geinfo->plugin)
			return -EINVAL;
	}

	plugin = geinfo->plugin;

	if (plugin->wmt_vpp_scl_scale) {
		src_fb = ge_helper_create_vdo_framebuf();
		dst_fb = ge_helper_create_vdo_framebuf();
		ge_helper_get_vdo_framebuf(src_fb, s, NULL);
		ge_helper_get_vdo_framebuf(dst_fb, d, NULL);
		if (src_fb && dst_fb)
			ret = plugin->wmt_vpp_scl_scale(src_fb, dst_fb);
		else
			ret = -ENOMEM;
		ge_helper_release_vdo_framebuf(src_fb);
		ge_helper_release_vdo_framebuf(dst_fb);
	} else
		return -EINVAL;

	/* ROP3 = PDo, A = 255, R, G, B */
	/*
	if (GE_BITS_PER_PIXEL(d->pixelformat) == 32)
		rop3(geinfo, NULL, &t, 0, 0, 0, 255, 0xfa);
	*/

	return ret;
#else  /* __LINUX__ */
	return -EPERM;
#endif /* __LINUX__ */
}

void ge_rgb_to_rgb(ge_info_t *geinfo,
		   ge_surface_t *s,
		   ge_surface_t *d,
		   ge_surface_t *o)
{
	ge_regs_t *regs = (ge_regs_t *)geinfo->mmio;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	if (o)
		ge_set_direct_write(geinfo, o);
	regs->src_csc_en = 0;
	regs->des_csc_en = 0;
	ge_set_src_csc(geinfo, GE_CSC_RGB_BYPASS);
	ge_set_dst_csc(geinfo, GE_CSC_RGB_BYPASS);
	regs->src_yuv_en = 0;
	regs->des_yuv_en = 0;
	regs->dw_yuv_en  = 0;
	ge_set_command(geinfo, GECMD_ALPHA_BITBLT, 0xcc);
	ge_wait_sync(geinfo);
}

void ge_yc_to_yc(ge_info_t *geinfo,
		 ge_surface_t *s,
		 ge_surface_t *d,
		 ge_surface_t *o)
{
	ge_regs_t *regs = (ge_regs_t *)geinfo->mmio;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	if (o)
		ge_set_direct_write(geinfo, o);
	regs->src_csc_en = 0;
	regs->des_csc_en = 0;
	ge_set_src_csc(geinfo, GE_CSC_YC_BYPASS);
	ge_set_dst_csc(geinfo, GE_CSC_YC_BYPASS);
	regs->src_yuv_en = s->pixelformat == GSPF_VPU ? 0 : 1;
	regs->des_yuv_en = 1;
	regs->dw_yuv_en  = 1;
	ge_set_command(geinfo, GECMD_ALPHA_BITBLT, 0xcc);
	ge_wait_sync(geinfo);
}

void ge_yc_to_rgb(ge_info_t *geinfo,
		  ge_surface_t *s,
		  ge_surface_t *d,
		  ge_surface_t *o)
{
	ge_regs_t *regs = (ge_regs_t *)geinfo->mmio;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	if (o)
		ge_set_direct_write(geinfo, o);
	regs->src_csc_en = 1;
	regs->des_csc_en = 0;
	ge_set_src_csc(geinfo, GE_CSC_YC_RGB_JFIF_0_255);
	ge_set_dst_csc(geinfo, GE_CSC_RGB_BYPASS);
	regs->src_yuv_en = s->pixelformat == GSPF_VPU ? 0 : 1;
	regs->des_yuv_en = 0;
	regs->dw_yuv_en  = 0;
	ge_set_command(geinfo, GECMD_ALPHA_BITBLT, 0xcc);
	ge_wait_sync(geinfo);
}

void ge_rgb_to_yc(ge_info_t *geinfo,
		  ge_surface_t *s,
		  ge_surface_t *d,
		  ge_surface_t *o)
{
	ge_regs_t *regs = (ge_regs_t *)geinfo->mmio;
	ge_set_source(geinfo, s);
	ge_set_destination(geinfo, d);
	if (o)
		ge_set_direct_write(geinfo, o);
	regs->src_csc_en = 1;
	regs->des_csc_en = 0;
	ge_set_src_csc(geinfo, GE_CSC_RGB_YC_JFIF_0_255);
	ge_set_dst_csc(geinfo, GE_CSC_YC_BYPASS);
	regs->src_yuv_en = 0;
	regs->des_yuv_en = 1;
	regs->dw_yuv_en  = 1;
	ge_set_command(geinfo, GECMD_ALPHA_BITBLT, 0xcc);
	ge_wait_sync(geinfo);
}

#ifdef __LINUX__
static void local_pixel_to_rgb(unsigned int pixel,
	unsigned int *r, unsigned int *g, unsigned int *b)
{
	*b = pixel & 0xff;
	pixel >>= 8;
	*g = pixel & 0xff;
	pixel >>= 8;
	*r = pixel & 0xff;
}

static int ge_save_image_ppm(ge_info_t *geinfo,
			     const ge_surface_t *s,
			     const char *name)
{
	ge_surface_t *clip;
	FILE *fd;
	unsigned int *pixel;
	unsigned int r;
	unsigned int g;
	unsigned int b;
	unsigned int i;
	unsigned int j;
	const int ver = 6; /* 3 (ascii) or 6 (binary) */

	clip = ge_create_surface(geinfo, s->xres, s->yres, GSPF_RGB32);
	ge_blit(geinfo, s, clip, 0, 0);

	ge_lock_surface(geinfo, clip, (void **) &pixel);
	fd = fopen(name, "w+");
	fprintf(fd, "P%d\n%lu %lu\n255\n", ver, clip->xres, clip->yres);
	for (i = 0; i < s->yres; i++) {
		for (j = 0; j < s->xres; j++) {
			local_pixel_to_rgb(*pixel, &r, &g, &b);
			if (ver == 3) {
				fprintf(fd, "%d %d %d ", r, g, b);
			} else {
				fwrite(&r, 1, 1, fd);
				fwrite(&g, 1, 1, fd);
				fwrite(&b, 1, 1, fd);
			}
			pixel++;
		}
		if (ver == 3)
			fprintf(fd, "\n");
	}
	fclose(fd);
	ge_unlock_surface(geinfo, clip);

	return 0;
}

int ge_save_image(ge_info_t *geinfo, const ge_surface_t *s, const char *name)
{
	return ge_save_image_ppm(geinfo, s, name);
}
#endif /* __LINUX__ */
